import{a as t}from"./chunk-4N75Z7F2.js";import"./chunk-XTBKSAXL.js";import"./chunk-F27AWPUY.js";import{a as e}from"./chunk-PJSC3CZC.js";import"./chunk-VKBMYYL4.js";import"./chunk-MQ2J7IEP.js";import"./chunk-LHHREGTA.js";import"./chunk-O2LOQWK4.js";import{a as i}from"./chunk-I4PVU2XE.js";import{a as n}from"./chunk-TMRGWDA2.js";import{b as o,c as r,d as a}from"./chunk-OST65WKL.js";import{d as s}from"./chunk-KLPRJ6SC.js";import"./chunk-4PT23TTH.js";import{a as m}from"./chunk-J4RA3VLE.js";import{a as l,d as p,f as u}from"./chunk-I4JBCTLR.js";import{a as h}from"./chunk-MCEXFPZL.js";import"./chunk-5IUKPU5Q.js";import"./chunk-B3NSNNUV.js";import{a as c}from"./chunk-BOXFFUY5.js";import{e as g}from"./chunk-OVZZEY7C.js";var f=new l,d=new l,y=new l,k=new l,w=new l,A=new l,_=new l;function v(t){let i=(t=t??u.EMPTY_OBJECT).positions,n=t.maximumHeights,o=t.minimumHeights;if(!g(i))throw new c("options.positions is required.");if(g(n)&&n.length!==i.length)throw new c("options.positions and options.maximumHeights must have the same length.");if(g(o)&&o.length!==i.length)throw new c("options.positions and options.minimumHeights must have the same length.");let r=t.vertexFormat??e.DEFAULT,a=t.granularity??h.RADIANS_PER_DEGREE,s=t.ellipsoid??p.default;this._positions=i,this._minimumHeights=o,this._maximumHeights=n,this._vertexFormat=e.clone(r),this._granularity=a,this._ellipsoid=p.clone(s),this._workerName="createWallGeometry";let m=1+i.length*l.packedLength+2;g(o)&&(m+=o.length),g(n)&&(m+=n.length),this.packedLength=m+p.packedLength+e.packedLength+1}v.pack=function(t,i,n){if(!g(t))throw new c("value is required");if(!g(i))throw new c("array is required");n=n??0;let o,r=t._positions,a=r.length;for(i[n++]=a,o=0;o<a;++o,n+=l.packedLength)l.pack(r[o],i,n);let s=t._minimumHeights;if(a=g(s)?s.length:0,i[n++]=a,g(s))for(o=0;o<a;++o)i[n++]=s[o];let m=t._maximumHeights;if(a=g(m)?m.length:0,i[n++]=a,g(m))for(o=0;o<a;++o)i[n++]=m[o];return p.pack(t._ellipsoid,i,n),n+=p.packedLength,e.pack(t._vertexFormat,i,n),i[n+=e.packedLength]=t._granularity,i};var x=p.clone(p.UNIT_SPHERE),L=new e,H={positions:void 0,minimumHeights:void 0,maximumHeights:void 0,ellipsoid:x,vertexFormat:L,granularity:void 0};v.unpack=function(t,i,n){let o,r;if(!g(t))throw new c("array is required");i=i??0;let a,s=t[i++],m=Array(s);for(a=0;a<s;++a,i+=l.packedLength)m[a]=l.unpack(t,i);if((s=t[i++])>0)for(o=Array(s),a=0;a<s;++a)o[a]=t[i++];if((s=t[i++])>0)for(r=Array(s),a=0;a<s;++a)r[a]=t[i++];let u=p.unpack(t,i,x);i+=p.packedLength;let h=e.unpack(t,i,L),f=t[i+=e.packedLength];return g(n)?(n._positions=m,n._minimumHeights=o,n._maximumHeights=r,n._ellipsoid=p.clone(u,n._ellipsoid),n._vertexFormat=e.clone(h,n._vertexFormat),n._granularity=f,n):(H.positions=m,H.minimumHeights=o,H.maximumHeights=r,H.granularity=f,new v(H))},v.fromConstantHeights=function(t){let e=(t=t??u.EMPTY_OBJECT).positions;if(!g(e))throw new c("options.positions is required.");let i,n,o=t.minimumHeight,r=t.maximumHeight,a=g(o),s=g(r);if(a||s){let t=e.length;i=a?Array(t):void 0,n=s?Array(t):void 0;for(let e=0;e<t;++e)a&&(i[e]=o),s&&(n[e]=r)}return new v({positions:e,maximumHeights:n,minimumHeights:i,ellipsoid:t.ellipsoid,vertexFormat:t.vertexFormat})},v.createGeometry=function(e){let p=e._positions,u=e._minimumHeights,c=e._maximumHeights,v=e._vertexFormat,x=e._granularity,L=e._ellipsoid,H=t.computePositions(L,p,c,u,x,!0);if(!g(H))return;let E=H.bottomPositions,F=H.topPositions,P=H.numCorners,T=F.length,j=2*T,b=v.position?new Float64Array(j):void 0,O=v.normal?new Float32Array(j):void 0,S=v.tangent?new Float32Array(j):void 0,z=v.bitangent?new Float32Array(j):void 0,C=v.st?new Float32Array(j/3*2):void 0,N=0,R=0,D=0,I=0,U=0,B=_,q=A,G=w,J=!0,Y,K=0,M=1/((T/=3)-P-1);for(Y=0;Y<T;++Y){let t=3*Y,e=l.fromArray(F,t,f),i=l.fromArray(E,t,d);if(v.position&&(b[N++]=i.x,b[N++]=i.y,b[N++]=i.z,b[N++]=e.x,b[N++]=e.y,b[N++]=e.z),v.st&&(C[U++]=K,C[U++]=0,C[U++]=K,C[U++]=1),v.normal||v.tangent||v.bitangent){let i=l.clone(l.ZERO,k),n=l.subtract(e,L.geodeticSurfaceNormal(e,d),d);if(Y+1<T&&(i=l.fromArray(F,t+3,k)),J){let t=l.subtract(i,e,y),o=l.subtract(n,e,f);B=l.normalize(l.cross(o,t,B),B),J=!1}l.equalsEpsilon(e,i,h.EPSILON10)?J=!0:(K+=M,v.tangent&&(q=l.normalize(l.subtract(i,e,q),q)),v.bitangent&&(G=l.normalize(l.cross(B,q,G),G))),v.normal&&(O[R++]=B.x,O[R++]=B.y,O[R++]=B.z,O[R++]=B.x,O[R++]=B.y,O[R++]=B.z),v.tangent&&(S[I++]=q.x,S[I++]=q.y,S[I++]=q.z,S[I++]=q.x,S[I++]=q.y,S[I++]=q.z),v.bitangent&&(z[D++]=G.x,z[D++]=G.y,z[D++]=G.z,z[D++]=G.x,z[D++]=G.y,z[D++]=G.z)}}let V=new n;v.position&&(V.position=new a({componentDatatype:m.DOUBLE,componentsPerAttribute:3,values:b})),v.normal&&(V.normal=new a({componentDatatype:m.FLOAT,componentsPerAttribute:3,values:O})),v.tangent&&(V.tangent=new a({componentDatatype:m.FLOAT,componentsPerAttribute:3,values:S})),v.bitangent&&(V.bitangent=new a({componentDatatype:m.FLOAT,componentsPerAttribute:3,values:z})),v.st&&(V.st=new a({componentDatatype:m.FLOAT,componentsPerAttribute:2,values:C}));let Z=j/3;j-=6*(P+1);let W=i.createTypedArray(Z,j),X=0;for(Y=0;Y<Z-2;Y+=2){let t=Y,e=Y+2,i=l.fromArray(b,3*t,f),n=l.fromArray(b,3*e,d);if(l.equalsEpsilon(i,n,h.EPSILON10))continue;let o=Y+1,r=Y+3;W[X++]=o,W[X++]=t,W[X++]=r,W[X++]=r,W[X++]=t,W[X++]=e}return new r({attributes:V,indices:W,primitiveType:o.TRIANGLES,boundingSphere:new s.fromVertices(b)})};var E=function(t,e){return g(e)&&(t=v.unpack(t,e)),t._ellipsoid=p.clone(t._ellipsoid),v.createGeometry(t)};export{E as default};