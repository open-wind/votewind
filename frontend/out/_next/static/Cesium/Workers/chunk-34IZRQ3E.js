import{a as t}from"./chunk-PWIRITCZ.js";import{a as e}from"./chunk-PYEWQREH.js";import{a as i}from"./chunk-7Q53UG4E.js";import{a as o}from"./chunk-HNJRTQHB.js";import{a as r}from"./chunk-PJSC3CZC.js";import{a as n}from"./chunk-I4PVU2XE.js";import{a as a}from"./chunk-TMRGWDA2.js";import{b as s,c as l,d as u}from"./chunk-OST65WKL.js";import{a as m,d as c}from"./chunk-KLPRJ6SC.js";import{f as p,h as h}from"./chunk-4PT23TTH.js";import{a as f}from"./chunk-J4RA3VLE.js";import{a as d,b as y,c as A,d as x,e as g,f as _}from"./chunk-I4JBCTLR.js";import{a as w}from"./chunk-MCEXFPZL.js";import{a as b,b as T}from"./chunk-BOXFFUY5.js";import{e as I}from"./chunk-OVZZEY7C.js";var E=new d,N=new d,M=new d,v=new d,P=new A,j=new g,F=new g,O=new p,S=new d,R=new d,L=new d,k=new y,D=new d,V=new A,z=new A;function C(e,i,r){let n=i.vertexFormat,s=i.center,l=i.semiMajorAxis,c=i.semiMinorAxis,h=i.ellipsoid,y=i.stRotation,x=r?e.length/3*2:e.length/3,_=i.shadowVolume,w=n.st?new Float32Array(2*x):void 0,b=n.normal?new Float32Array(3*x):void 0,T=n.tangent?new Float32Array(3*x):void 0,v=n.bitangent?new Float32Array(3*x):void 0,C=_?new Float32Array(3*x):void 0,G=0,Y=S,B=R,H=L,U=new m(h),J=U.project(h.cartesianToCartographic(s,k),D),Q=h.scaleToGeodeticSurface(s,E);h.geodeticSurfaceNormal(Q,Q);let W=j,Z=F;if(0!==y){let t=p.fromAxisAngle(Q,y,O);W=g.fromQuaternion(t,W),t=p.fromAxisAngle(Q,-y,O),Z=g.fromQuaternion(t,Z)}else W=g.clone(g.IDENTITY,W),Z=g.clone(g.IDENTITY,Z);let q=A.fromElements(Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY,V),X=A.fromElements(Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY,z),K=e.length,$=r?K:0,tt=$/3*2;for(let t=0;t<K;t+=3){let i=t+1,o=t+2,a=d.fromArray(e,t,E);if(n.st){let t=g.multiplyByVector(W,a,N),e=U.project(h.cartesianToCartographic(t,k),M);d.subtract(e,J,e),P.x=(e.x+l)/(2*l),P.y=(e.y+c)/(2*c),q.x=Math.min(P.x,q.x),q.y=Math.min(P.y,q.y),X.x=Math.max(P.x,X.x),X.y=Math.max(P.y,X.y),r&&(w[G+tt]=P.x,w[G+1+tt]=P.y),w[G++]=P.x,w[G++]=P.y}(n.normal||n.tangent||n.bitangent||_)&&(Y=h.geodeticSurfaceNormal(a,Y),_&&(C[t+$]=-Y.x,C[i+$]=-Y.y,C[o+$]=-Y.z),(n.normal||n.tangent||n.bitangent)&&((n.tangent||n.bitangent)&&(B=d.normalize(d.cross(d.UNIT_Z,Y,B),B),g.multiplyByVector(Z,B,B)),n.normal&&(b[t]=Y.x,b[i]=Y.y,b[o]=Y.z,r&&(b[t+$]=-Y.x,b[i+$]=-Y.y,b[o+$]=-Y.z)),n.tangent&&(T[t]=B.x,T[i]=B.y,T[o]=B.z,r&&(T[t+$]=-B.x,T[i+$]=-B.y,T[o+$]=-B.z)),n.bitangent&&(H=d.normalize(d.cross(Y,B,H),H),v[t]=H.x,v[i]=H.y,v[o]=H.z,r&&(v[t+$]=H.x,v[i+$]=H.y,v[o+$]=H.z))))}if(n.st){K=w.length;for(let t=0;t<K;t+=2)w[t]=(w[t]-q.x)/(X.x-q.x),w[t+1]=(w[t+1]-q.y)/(X.y-q.y)}let te=new a;if(n.position){let o=t.raisePositionsToHeight(e,i,r);te.position=new u({componentDatatype:f.DOUBLE,componentsPerAttribute:3,values:o})}if(n.st&&(te.st=new u({componentDatatype:f.FLOAT,componentsPerAttribute:2,values:w})),n.normal&&(te.normal=new u({componentDatatype:f.FLOAT,componentsPerAttribute:3,values:b})),n.tangent&&(te.tangent=new u({componentDatatype:f.FLOAT,componentsPerAttribute:3,values:T})),n.bitangent&&(te.bitangent=new u({componentDatatype:f.FLOAT,componentsPerAttribute:3,values:v})),_&&(te.extrudeDirection=new u({componentDatatype:f.FLOAT,componentsPerAttribute:3,values:C})),r&&I(i.offsetAttribute)){let t=new Uint8Array(x);if(i.offsetAttribute===o.TOP)t=t.fill(1,0,x/2);else{let e=i.offsetAttribute===o.NONE?0:1;t=t.fill(e)}te.applyOffset=new u({componentDatatype:f.UNSIGNED_BYTE,componentsPerAttribute:1,values:t})}return te}function G(t){let e=Array(t*(t+1)*12-6),i=0,o,r,n,a,s;for(o=0,n=1,a=0;a<3;a++)e[i++]=n++,e[i++]=o,e[i++]=n;for(a=2;a<t+1;++a){for(n=a*(a+1)-1,o=(a-1)*a-1,e[i++]=n++,e[i++]=o,e[i++]=n,r=2*a,s=0;s<r-1;++s)e[i++]=n,e[i++]=o++,e[i++]=o,e[i++]=n++,e[i++]=o,e[i++]=n;e[i++]=n++,e[i++]=o,e[i++]=n}for(r=2*t,++n,++o,a=0;a<r-1;++a)e[i++]=n,e[i++]=o++,e[i++]=o,e[i++]=n++,e[i++]=o,e[i++]=n;for(e[i++]=n,e[i++]=o++,e[i++]=o,e[i++]=n++,e[i++]=o++,e[i++]=o,++o,a=t-1;a>1;--a){for(e[i++]=o++,e[i++]=o,e[i++]=n,r=2*a,s=0;s<r-1;++s)e[i++]=n,e[i++]=o++,e[i++]=o,e[i++]=n++,e[i++]=o,e[i++]=n;e[i++]=o++,e[i++]=o++,e[i++]=n++}for(a=0;a<3;a++)e[i++]=o++,e[i++]=o,e[i++]=n;return e}var Y=new d,B=new c,H=new c;function U(e,i,o,r,n,a,s){let l=t.computeEllipsePositions({center:e,semiMajorAxis:i,semiMinorAxis:o,rotation:r,granularity:n},!1,!0).outerPositions,u=l.length/3,m=Array(u);for(let t=0;t<u;++t)m[t]=d.fromArray(l,3*t);let c=h.fromCartesianArray(m,a,s);return c.width>w.PI&&(c.north=c.north>0?w.PI_OVER_TWO-w.EPSILON7:c.north,c.south=c.south<0?w.EPSILON7-w.PI_OVER_TWO:c.south,c.east=w.PI,c.west=-w.PI),c}function J(t){let e=(t=t??_.EMPTY_OBJECT).center,i=t.ellipsoid??x.default,o=t.semiMajorAxis,n=t.semiMinorAxis,a=t.granularity??w.RADIANS_PER_DEGREE,s=t.vertexFormat??r.DEFAULT;if(T.defined("options.center",e),T.typeOf.number("options.semiMajorAxis",o),T.typeOf.number("options.semiMinorAxis",n),o<n)throw new b("semiMajorAxis must be greater than or equal to the semiMinorAxis.");if(a<=0)throw new b("granularity must be greater than zero.");let l=t.height??0,u=t.extrudedHeight??l;this._center=d.clone(e),this._semiMajorAxis=o,this._semiMinorAxis=n,this._ellipsoid=x.clone(i),this._rotation=t.rotation??0,this._stRotation=t.stRotation??0,this._height=Math.max(u,l),this._granularity=a,this._vertexFormat=r.clone(s),this._extrudedHeight=Math.min(u,l),this._shadowVolume=t.shadowVolume??!1,this._workerName="createEllipseGeometry",this._offsetAttribute=t.offsetAttribute,this._rectangle=void 0,this._textureCoordinateRotationPoints=void 0}J.packedLength=d.packedLength+x.packedLength+r.packedLength+9,J.pack=function(t,e,i){return T.defined("value",t),T.defined("array",e),i=i??0,d.pack(t._center,e,i),i+=d.packedLength,x.pack(t._ellipsoid,e,i),i+=x.packedLength,r.pack(t._vertexFormat,e,i),i+=r.packedLength,e[i++]=t._semiMajorAxis,e[i++]=t._semiMinorAxis,e[i++]=t._rotation,e[i++]=t._stRotation,e[i++]=t._height,e[i++]=t._granularity,e[i++]=t._extrudedHeight,e[i++]=t._shadowVolume?1:0,e[i]=t._offsetAttribute??-1,e};var Q=new d,W=new x,Z=new r,q={center:Q,ellipsoid:W,vertexFormat:Z,semiMajorAxis:void 0,semiMinorAxis:void 0,rotation:void 0,stRotation:void 0,height:void 0,granularity:void 0,extrudedHeight:void 0,shadowVolume:void 0,offsetAttribute:void 0};J.unpack=function(t,e,i){T.defined("array",t),e=e??0;let o=d.unpack(t,e,Q);e+=d.packedLength;let n=x.unpack(t,e,W);e+=x.packedLength;let a=r.unpack(t,e,Z);e+=r.packedLength;let s=t[e++],l=t[e++],u=t[e++],m=t[e++],c=t[e++],p=t[e++],h=t[e++],f=1===t[e++],y=t[e];return I(i)?(i._center=d.clone(o,i._center),i._ellipsoid=x.clone(n,i._ellipsoid),i._vertexFormat=r.clone(a,i._vertexFormat),i._semiMajorAxis=s,i._semiMinorAxis=l,i._rotation=u,i._stRotation=m,i._height=c,i._granularity=p,i._extrudedHeight=h,i._shadowVolume=f,i._offsetAttribute=-1===y?void 0:y,i):(q.height=c,q.extrudedHeight=h,q.granularity=p,q.stRotation=m,q.rotation=u,q.semiMajorAxis=s,q.semiMinorAxis=l,q.shadowVolume=f,q.offsetAttribute=-1===y?void 0:y,new J(q))},J.computeRectangle=function(t,e){let i=(t=t??_.EMPTY_OBJECT).center,o=t.ellipsoid??x.default,r=t.semiMajorAxis,n=t.semiMinorAxis,a=t.granularity??w.RADIANS_PER_DEGREE,s=t.rotation??0;if(T.defined("options.center",i),T.typeOf.number("options.semiMajorAxis",r),T.typeOf.number("options.semiMinorAxis",n),r<n)throw new b("semiMajorAxis must be greater than or equal to the semiMinorAxis.");if(a<=0)throw new b("granularity must be greater than zero.");return U(i,r,n,s,a,o,e)},J.createGeometry=function(r){if(r._semiMajorAxis<=0||r._semiMinorAxis<=0)return;let h=r._height,y=r._extrudedHeight,x=!w.equalsEpsilon(h,y,0,w.EPSILON2);r._center=r._ellipsoid.scaleToGeodeticSurface(r._center,r._center);let _={center:r._center,semiMajorAxis:r._semiMajorAxis,semiMinorAxis:r._semiMinorAxis,ellipsoid:r._ellipsoid,rotation:r._rotation,height:h,granularity:r._granularity,vertexFormat:r._vertexFormat,stRotation:r._stRotation},b;if(x)_.extrudedHeight=y,_.shadowVolume=r._shadowVolume,_.offsetAttribute=r._offsetAttribute,b=function(r){let h=r.center,y=r.ellipsoid,x=r.semiMajorAxis,_=d.multiplyByScalar(y.geodeticSurfaceNormal(h,E),r.height,E);B.center=d.add(h,_,B.center),B.radius=x,_=d.multiplyByScalar(y.geodeticSurfaceNormal(h,_),r.extrudedHeight,_),H.center=d.add(h,_,H.center),H.radius=x;let w=t.computeEllipsePositions(r,!0,!0),b=w.positions,T=w.numPts,F=w.outerPositions,Y=c.union(B,H),U=C(b,r,!0),J=G(T),Q=J.length;J.length=2*Q;let W=b.length/3;for(let t=0;t<Q;t+=3)J[t+Q]=J[t+2]+W,J[t+1+Q]=J[t+1]+W,J[t+2+Q]=J[t]+W;let Z=new l({attributes:U,indices:n.createTypedArray(2*W/3,J),primitiveType:s.TRIANGLES}),q=function(t,e){let i=e.vertexFormat,r=e.center,n=e.semiMajorAxis,s=e.semiMinorAxis,l=e.ellipsoid,c=e.height,h=e.extrudedHeight,y=e.stRotation,x=t.length/3*2,_=new Float64Array(3*x),w=i.st?new Float32Array(2*x):void 0,b=i.normal?new Float32Array(3*x):void 0,T=i.tangent?new Float32Array(3*x):void 0,F=i.bitangent?new Float32Array(3*x):void 0,C=e.shadowVolume,G=C?new Float32Array(3*x):void 0,Y=0,B=S,H=R,U=L,J=new m(l),Q=J.project(l.cartesianToCartographic(r,k),D),W=l.scaleToGeodeticSurface(r,E);l.geodeticSurfaceNormal(W,W);let Z=p.fromAxisAngle(W,y,O),q=g.fromQuaternion(Z,j),X=A.fromElements(Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY,V),K=A.fromElements(Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY,z),$=t.length,tt=$/3*2;for(let e=0;e<$;e+=3){let o=e+1,r=e+2,a=d.fromArray(t,e,E),u;if(i.st){let t=g.multiplyByVector(q,a,N),e=J.project(l.cartesianToCartographic(t,k),M);d.subtract(e,Q,e),P.x=(e.x+n)/(2*n),P.y=(e.y+s)/(2*s),X.x=Math.min(P.x,X.x),X.y=Math.min(P.y,X.y),K.x=Math.max(P.x,K.x),K.y=Math.max(P.y,K.y),w[Y+tt]=P.x,w[Y+1+tt]=P.y,w[Y++]=P.x,w[Y++]=P.y}a=l.scaleToGeodeticSurface(a,a),u=d.clone(a,N),B=l.geodeticSurfaceNormal(a,B),C&&(G[e+$]=-B.x,G[o+$]=-B.y,G[r+$]=-B.z);let m=d.multiplyByScalar(B,c,v);if(a=d.add(a,m,a),m=d.multiplyByScalar(B,h,m),u=d.add(u,m,u),i.position&&(_[e+$]=u.x,_[o+$]=u.y,_[r+$]=u.z,_[e]=a.x,_[o]=a.y,_[r]=a.z),i.normal||i.tangent||i.bitangent){U=d.clone(B,U);let n=d.fromArray(t,(e+3)%$,v);d.subtract(n,a,n);let s=d.subtract(u,a,M);B=d.normalize(d.cross(s,n,B),B),i.normal&&(b[e]=B.x,b[o]=B.y,b[r]=B.z,b[e+$]=B.x,b[o+$]=B.y,b[r+$]=B.z),i.tangent&&(H=d.normalize(d.cross(U,B,H),H),T[e]=H.x,T[o]=H.y,T[r]=H.z,T[e+$]=H.x,T[e+1+$]=H.y,T[e+2+$]=H.z),i.bitangent&&(F[e]=U.x,F[o]=U.y,F[r]=U.z,F[e+$]=U.x,F[o+$]=U.y,F[r+$]=U.z)}}if(i.st){$=w.length;for(let t=0;t<$;t+=2)w[t]=(w[t]-X.x)/(K.x-X.x),w[t+1]=(w[t+1]-X.y)/(K.y-X.y)}let te=new a;if(i.position&&(te.position=new u({componentDatatype:f.DOUBLE,componentsPerAttribute:3,values:_})),i.st&&(te.st=new u({componentDatatype:f.FLOAT,componentsPerAttribute:2,values:w})),i.normal&&(te.normal=new u({componentDatatype:f.FLOAT,componentsPerAttribute:3,values:b})),i.tangent&&(te.tangent=new u({componentDatatype:f.FLOAT,componentsPerAttribute:3,values:T})),i.bitangent&&(te.bitangent=new u({componentDatatype:f.FLOAT,componentsPerAttribute:3,values:F})),C&&(te.extrudeDirection=new u({componentDatatype:f.FLOAT,componentsPerAttribute:3,values:G})),I(e.offsetAttribute)){let t=new Uint8Array(x);if(e.offsetAttribute===o.TOP)t=t.fill(1,0,x/2);else{let i=e.offsetAttribute===o.NONE?0:1;t=t.fill(i)}te.applyOffset=new u({componentDatatype:f.UNSIGNED_BYTE,componentsPerAttribute:1,values:t})}return te}(F,r);J=function(t){let e=t.length/3,i=n.createTypedArray(e,6*e),o=0;for(let t=0;t<e;t++){let r=t,n=t+e,a=(r+1)%e,s=a+e;i[o++]=r,i[o++]=n,i[o++]=a,i[o++]=a,i[o++]=n,i[o++]=s}return i}(F);let X=new l({attributes:q,indices:n.createTypedArray(2*F.length/3,J),primitiveType:s.TRIANGLES}),K=i.combineInstances([new e({geometry:Z}),new e({geometry:X})]);return{boundingSphere:Y,attributes:K[0].attributes,indices:K[0].indices}}(_);else{let e,i,a,s,l,m,p;if(e=_.center,Y=d.multiplyByScalar(_.ellipsoid.geodeticSurfaceNormal(e,Y),_.height,Y),i=new c(Y=d.add(e,Y,Y),_.semiMajorAxis),s=(a=t.computeEllipsePositions(_,!0,!1)).positions,l=a.numPts,m=C(s,_,!1),p=G(l),b={boundingSphere:i,attributes:m,indices:p=n.createTypedArray(s.length/3,p)},I(r._offsetAttribute)){let t=b.attributes.position.values.length,e=r._offsetAttribute===o.NONE?0:1,i=new Uint8Array(t/3).fill(e);b.attributes.applyOffset=new u({componentDatatype:f.UNSIGNED_BYTE,componentsPerAttribute:1,values:i})}}return new l({attributes:b.attributes,indices:b.indices,primitiveType:s.TRIANGLES,boundingSphere:b.boundingSphere,offsetAttribute:r._offsetAttribute})},J.createShadowVolume=function(t,e,i){let o=t._granularity,n=t._ellipsoid,a=e(o,n),s=i(o,n);return new J({center:t._center,semiMajorAxis:t._semiMajorAxis,semiMinorAxis:t._semiMinorAxis,ellipsoid:n,rotation:t._rotation,stRotation:t._stRotation,granularity:o,extrudedHeight:a,height:s,vertexFormat:r.POSITION_ONLY,shadowVolume:!0})},Object.defineProperties(J.prototype,{rectangle:{get:function(){return I(this._rectangle)||(this._rectangle=U(this._center,this._semiMajorAxis,this._semiMinorAxis,this._rotation,this._granularity,this._ellipsoid)),this._rectangle}},textureCoordinateRotationPoints:{get:function(){return I(this._textureCoordinateRotationPoints)||(this._textureCoordinateRotationPoints=function(e){let i=-e._stRotation;if(0===i)return[0,0,0,1,1,0];let o=t.computeEllipsePositions({center:e._center,semiMajorAxis:e._semiMajorAxis,semiMinorAxis:e._semiMinorAxis,rotation:e._rotation,granularity:e._granularity},!1,!0).outerPositions,r=o.length/3,n=Array(r);for(let t=0;t<r;++t)n[t]=d.fromArray(o,3*t);let a=e._ellipsoid,s=e.rectangle;return l._textureCoordinateRotationPoints(n,i,a,s)}(this)),this._textureCoordinateRotationPoints}}});var X=J;export{X as a};