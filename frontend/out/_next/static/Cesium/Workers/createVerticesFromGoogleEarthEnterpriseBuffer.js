import{a as t,b as e}from"./chunk-FVPDHHYC.js";import{a as i}from"./chunk-3WQQGQIW.js";import{a as n}from"./chunk-R6YCVUGT.js";import{a as o}from"./chunk-UYGXVO4A.js";import"./chunk-OFGHX2F3.js";import"./chunk-VRX6MZUH.js";import{a as r}from"./chunk-EMIRY7IE.js";import"./chunk-LHHREGTA.js";import"./chunk-O2LOQWK4.js";import{d as a}from"./chunk-KLPRJ6SC.js";import{b as s,g as u,h as l}from"./chunk-4PT23TTH.js";import"./chunk-J4RA3VLE.js";import{a as h,b as c,c as d,d as m}from"./chunk-I4JBCTLR.js";import{a as g}from"./chunk-MCEXFPZL.js";import"./chunk-5IUKPU5Q.js";import{a as p}from"./chunk-B3NSNNUV.js";import"./chunk-BOXFFUY5.js";import{e as I}from"./chunk-OVZZEY7C.js";var E=Uint16Array.BYTES_PER_ELEMENT,f=Int32Array.BYTES_PER_ELEMENT,T=Uint32Array.BYTES_PER_ELEMENT,N=Float32Array.BYTES_PER_ELEMENT,x=Float64Array.BYTES_PER_ELEMENT;function S(t,e,i){i=i??g;let n=t.length;for(let o=0;o<n;++o)if(i.equalsEpsilon(t[o],e,g.EPSILON12))return o;return -1}var R=new c,P=new h,b=new h,k=new h,A=new s;function F(t,e,i,n,o,r,a,u,l,m,p){let E=u.length;for(let f=0;f<E;++f){let T=u[f],N=T.cartographic,x=T.index,S=t.length,b=N.longitude,k=N.latitude;k=g.clamp(k,-g.PI_OVER_TWO,g.PI_OVER_TWO);let A=N.height-a.skirtHeight;a.hMin=Math.min(a.hMin,A),c.fromRadians(b,k,A,R),m&&(R.longitude+=l),m?f===E-1?R.latitude+=p:0===f&&(R.latitude-=p):R.latitude+=l;let F=a.ellipsoid.cartographicToCartesian(R);t.push(F),e.push(A),i.push(d.clone(i[x])),n.length>0&&n.push(n[x]),o.length>0&&o.push(o[x]),s.multiplyByPoint(a.toENU,F,P);let y=a.minimum,w=a.maximum;h.minimumByComponent(P,y,y),h.maximumByComponent(P,w,w);let B=a.lastBorderPoint;if(I(B)){let t=B.index;r.push(t,S-1,S,S,x,t)}a.lastBorderPoint=T}}var y=i(function(i,y){i.ellipsoid=m.clone(i.ellipsoid),i.rectangle=l.clone(i.rectangle);let w=function(i,l,m,y,w,B,M,v,_,C,U){let Y,j,H,V,W,O;I(y)?(Y=y.west,j=y.south,H=y.east,V=y.north,W=y.width,O=y.height):(Y=g.toRadians(w.west),j=g.toRadians(w.south),H=g.toRadians(w.east),V=g.toRadians(w.north),W=g.toRadians(y.width),O=g.toRadians(y.height));let L=[j,V],G=[Y,H],D=u.eastNorthUpToFixedFrame(l,m),Q=s.inverseTransformation(D,A),X,Z;_&&(X=n.geodeticLatitudeToMercatorAngle(j),Z=1/(n.geodeticLatitudeToMercatorAngle(V)-X));let z=1!==B,J=new DataView(i),K=Number.POSITIVE_INFINITY,q=Number.NEGATIVE_INFINITY;b.x=Number.POSITIVE_INFINITY,b.y=Number.POSITIVE_INFINITY,b.z=Number.POSITIVE_INFINITY,k.x=Number.NEGATIVE_INFINITY,k.y=Number.NEGATIVE_INFINITY,k.z=Number.NEGATIVE_INFINITY;let $=0,tt=0,te=0,ti,tn;for(tn=0;tn<4;++tn){let t=$;ti=J.getUint32(t,!0),t+=T;let e=g.toRadians(180*J.getFloat64(t,!0));t+=x,-1===S(G,e)&&G.push(e);let i=g.toRadians(180*J.getFloat64(t,!0));t+=x,-1===S(L,i)&&L.push(i),t+=2*x;let n=J.getInt32(t,!0);t+=f,tt+=n,te+=3*(n=J.getInt32(t,!0)),$+=ti+T}let to=[],tr=[],ta=Array(tt),ts=Array(tt),tu=Array(tt),tl=_?Array(tt):[],th=z?Array(tt):[],tc=Array(te),td=[],tm=[],tg=[],tp=[],tI=0,tE=0;for($=0,tn=0;tn<4;++tn){ti=J.getUint32($,!0);let t=$+=T,e=g.toRadians(180*J.getFloat64($,!0));$+=x;let i=g.toRadians(180*J.getFloat64($,!0));$+=x;let o=g.toRadians(180*J.getFloat64($,!0)),r=.5*o;$+=x;let a=g.toRadians(180*J.getFloat64($,!0)),u=.5*a;$+=x;let l=J.getInt32($,!0);$+=f;let I=J.getInt32($,!0);$+=f,$+=f;let A=Array(l);for(let t=0;t<l;++t){let l=e+J.getUint8($++)*o;R.longitude=l;let p=i+J.getUint8($++)*a;R.latitude=p;let I=J.getFloat32($,!0);if($+=N,0!==I&&I<U&&(I*=-Math.pow(2,C)),I*=6371010,R.height=I,-1!==S(G,l)||-1!==S(L,p)){let e=S(to,R,c);if(-1===e)to.push(c.clone(R)),tr.push(tI);else{A[t]=tr[e];continue}}A[t]=tI,Math.abs(l-Y)<r?td.push({index:tI,cartographic:c.clone(R)}):Math.abs(l-H)<r?tg.push({index:tI,cartographic:c.clone(R)}):Math.abs(p-j)<u?tm.push({index:tI,cartographic:c.clone(R)}):Math.abs(p-V)<u&&tp.push({index:tI,cartographic:c.clone(R)}),K=Math.min(I,K),q=Math.max(I,q),tu[tI]=I;let E=m.cartographicToCartesian(R);if(ta[tI]=E,_&&(tl[tI]=(n.geodeticLatitudeToMercatorAngle(p)-X)*Z),z){let t=m.geodeticSurfaceNormal(E);th[tI]=t}s.multiplyByPoint(Q,E,P),h.minimumByComponent(P,b,b),h.maximumByComponent(P,k,k);let f=(l-Y)/(H-Y);f=g.clamp(f,0,1);let T=(p-j)/(V-j);T=g.clamp(T,0,1),ts[tI]=new d(f,T),++tI}let F=3*I;for(let t=0;t<F;++t,++tE)tc[tE]=A[J.getUint16($,!0)],$+=E;if(ti!==$-t)throw new p("Invalid terrain tile.")}ta.length=tI,ts.length=tI,tu.length=tI,_&&(tl.length=tI),z&&(th.length=tI);let tf=tI,tT=tE,tN={hMin:K,lastBorderPoint:void 0,skirtHeight:v,toENU:Q,ellipsoid:m,minimum:b,maximum:k};if(td.sort(function(t,e){return e.cartographic.latitude-t.cartographic.latitude}),tm.sort(function(t,e){return t.cartographic.longitude-e.cartographic.longitude}),tg.sort(function(t,e){return t.cartographic.latitude-e.cartographic.latitude}),tp.sort(function(t,e){return e.cartographic.longitude-t.cartographic.longitude}),F(ta,tu,ts,tl,th,tc,tN,td,-1e-5*W,!0,-1e-5*O),F(ta,tu,ts,tl,th,tc,tN,tm,-1e-5*O,!1),F(ta,tu,ts,tl,th,tc,tN,tg,1e-5*W,!0,1e-5*O),F(ta,tu,ts,tl,th,tc,tN,tp,1e-5*O,!1),td.length>0&&tp.length>0){let t=td[0].index,e=tp[tp.length-1].index,i=ta.length-1;tc.push(e,i,tf,tf,t,e)}tt=ta.length;let tx=a.fromPoints(ta),tS;I(y)&&(tS=o.fromRectangle(y,K,q,m));let tR=new t(m).computeHorizonCullingPointPossiblyUnderEllipsoid(l,ta,K),tP=new r(b,k,l),tb=new e(l,tP,tN.hMin,q,D,!1,_,z,B,M),tk=new Float32Array(tt*tb.stride),tA=0;for(let t=0;t<tt;++t)tA=tb.encode(tk,tA,ta[t],ts[t],tu[t],void 0,tl[t],th[t]);let tF=td.map(function(t){return t.index}).reverse(),ty=tm.map(function(t){return t.index}).reverse(),tw=tg.map(function(t){return t.index}).reverse(),tB=tp.map(function(t){return t.index}).reverse();return ty.unshift(tw[tw.length-1]),ty.push(tF[0]),tB.unshift(tF[tF.length-1]),tB.push(tw[0]),{vertices:tk,indices:new Uint16Array(tc),maximumHeight:q,minimumHeight:K,encoding:tb,boundingSphere3D:tx,orientedBoundingBox:tS,occludeePointInScaledSpace:tR,vertexCountWithoutSkirts:tf,indexCountWithoutSkirts:tT,westIndicesSouthToNorth:tF,southIndicesEastToWest:ty,eastIndicesNorthToSouth:tw,northIndicesWestToEast:tB}}(i.buffer,i.relativeToCenter,i.ellipsoid,i.rectangle,i.nativeRectangle,i.exaggeration,i.exaggerationRelativeHeight,i.skirtHeight,i.includeWebMercatorT,i.negativeAltitudeExponentBias,i.negativeElevationThreshold),B=w.vertices;y.push(B.buffer);let M=w.indices;return y.push(M.buffer),{vertices:B.buffer,indices:M.buffer,numberOfAttributes:w.encoding.stride,minimumHeight:w.minimumHeight,maximumHeight:w.maximumHeight,boundingSphere3D:w.boundingSphere3D,orientedBoundingBox:w.orientedBoundingBox,occludeePointInScaledSpace:w.occludeePointInScaledSpace,encoding:w.encoding,vertexCountWithoutSkirts:w.vertexCountWithoutSkirts,indexCountWithoutSkirts:w.indexCountWithoutSkirts,westIndicesSouthToNorth:w.westIndicesSouthToNorth,southIndicesEastToWest:w.southIndicesEastToWest,eastIndicesNorthToSouth:w.eastIndicesNorthToSouth,northIndicesWestToEast:w.northIndicesWestToEast}});export{y as default};