import{a as t}from"./chunk-GSY3BJ4Q.js";import{a as e}from"./chunk-DZK6I6VG.js";import"./chunk-UYGXVO4A.js";import{a as n}from"./chunk-NHZSQ3M4.js";import"./chunk-4KTYBIT7.js";import{a as o}from"./chunk-PYEWQREH.js";import{a as r}from"./chunk-7Q53UG4E.js";import"./chunk-OFGHX2F3.js";import"./chunk-GT4KWHVH.js";import{a as i}from"./chunk-PJSC3CZC.js";import"./chunk-VRX6MZUH.js";import"./chunk-EMIRY7IE.js";import{b as a}from"./chunk-AKNTYFRF.js";import{a as s}from"./chunk-VKBMYYL4.js";import"./chunk-MQ2J7IEP.js";import"./chunk-LHHREGTA.js";import"./chunk-O2LOQWK4.js";import{a as c}from"./chunk-I4PVU2XE.js";import{a as p}from"./chunk-TMRGWDA2.js";import{b as l,c as u,d as m}from"./chunk-OST65WKL.js";import{d as h}from"./chunk-KLPRJ6SC.js";import{f as y}from"./chunk-4PT23TTH.js";import{a as g}from"./chunk-J4RA3VLE.js";import{a as d,c as f,d as k,e as w,f as j}from"./chunk-I4JBCTLR.js";import{a as T}from"./chunk-MCEXFPZL.js";import"./chunk-5IUKPU5Q.js";import"./chunk-B3NSNNUV.js";import{b as x}from"./chunk-BOXFFUY5.js";import{e as P}from"./chunk-OVZZEY7C.js";var v=new d,F=new t,A=new f,L=new f,_=new d,H=new d,b=new d,E=new d,R=new d,C=new d,I=new y,O=new w,D=new w,Y=new d;function B(t){let e=(t=t??j.EMPTY_OBJECT).polygonHierarchy,o=t.textureCoordinates;x.defined("options.polygonHierarchy",e);let r=t.vertexFormat??i.DEFAULT;this._vertexFormat=i.clone(r),this._polygonHierarchy=e,this._stRotation=t.stRotation??0,this._ellipsoid=k.clone(t.ellipsoid??k.default),this._workerName="createCoplanarPolygonGeometry",this._textureCoordinates=o,this.packedLength=n.computeHierarchyPackedLength(e,d)+i.packedLength+k.packedLength+(P(o)?n.computeHierarchyPackedLength(o,f):1)+2}B.fromPositions=function(t){return t=t??j.EMPTY_OBJECT,x.defined("options.positions",t.positions),new B({polygonHierarchy:{positions:t.positions},vertexFormat:t.vertexFormat,stRotation:t.stRotation,ellipsoid:t.ellipsoid,textureCoordinates:t.textureCoordinates})},B.pack=function(t,e,o){return x.typeOf.object("value",t),x.defined("array",e),o=o??0,o=n.packPolygonHierarchy(t._polygonHierarchy,e,o,d),k.pack(t._ellipsoid,e,o),o+=k.packedLength,i.pack(t._vertexFormat,e,o),o+=i.packedLength,e[o++]=t._stRotation,P(t._textureCoordinates)?o=n.packPolygonHierarchy(t._textureCoordinates,e,o,f):e[o++]=-1,e[o++]=t.packedLength,e};var G=k.clone(k.UNIT_SPHERE),N=new i,S={polygonHierarchy:{}};B.unpack=function(t,e,o){x.defined("array",t),e=e??0;let r=n.unpackPolygonHierarchy(t,e,d);e=r.startingIndex,delete r.startingIndex;let a=k.unpack(t,e,G);e+=k.packedLength;let s=i.unpack(t,e,N);e+=i.packedLength;let c=t[e++],p=-1===t[e]?void 0:n.unpackPolygonHierarchy(t,e,f);P(p)?(e=p.startingIndex,delete p.startingIndex):e++;let l=t[e++];return P(o)||(o=new B(S)),o._polygonHierarchy=r,o._ellipsoid=k.clone(a,o._ellipsoid),o._vertexFormat=i.clone(s,o._vertexFormat),o._stRotation=c,o._textureCoordinates=p,o.packedLength=l,o},B.createGeometry=function(t){let i=t._vertexFormat,k=t._polygonHierarchy,j=t._stRotation,x=t._textureCoordinates,B=P(x),G=k.positions;if((G=s(G,d.equalsEpsilon,!0)).length<3)return;let N=_,S=H,U=b,V=R;if(!e.computeProjectTo2DArguments(G,E,V,C))return;if(N=d.cross(V,C,N),N=d.normalize(N,N),!d.equalsEpsilon(E,d.ZERO,T.EPSILON6)){let e=t._ellipsoid.geodeticSurfaceNormal(E,Y);0>d.dot(N,e)&&(N=d.negate(N,N),V=d.negate(V,V))}let K=e.createProjectPointsTo2DFunction(E,V,C),M=e.createProjectPointTo2DFunction(E,V,C);i.tangent&&(S=d.clone(V,S)),i.bitangent&&(U=d.clone(C,U));let Q=n.polygonsFromHierarchy(k,B,K,!1),J=Q.hierarchy,Z=Q.polygons,z=B?n.polygonsFromHierarchy(x,!0,function(t){return t},!1).polygons:void 0;if(0===J.length)return;G=J[0].outerRing;let X=h.fromPoints(G),W=n.computeBoundingRectangle(N,M,G,j,F),q=[];for(let t=0;t<Z.length;t++){let e=new o({geometry:function(t,e,n,o,r,i,s,h,k){let j=t.positions,x=a.triangulate(t.positions2D,t.holes);x.length<3&&(x=[0,1,2]);let F=c.createTypedArray(j.length,x.length);F.set(x);let _=O;if(0!==o){let t=y.fromAxisAngle(s,o,I);if(_=w.fromQuaternion(t,_),e.tangent||e.bitangent){t=y.fromAxisAngle(s,-o,I);let n=w.fromQuaternion(t,D);h=d.normalize(w.multiplyByVector(n,h,h),h),e.bitangent&&(k=d.normalize(d.cross(s,h,k),k))}}else _=w.clone(w.IDENTITY,_);e.st&&(L.x=n.x,L.y=n.y);let H=j.length,b=3*H,E=new Float64Array(b),R=e.normal?new Float32Array(b):void 0,C=e.tangent?new Float32Array(b):void 0,Y=e.bitangent?new Float32Array(b):void 0,B=e.st?new Float32Array(2*H):void 0,G=0,N=0,S=0,U=0,V=0;for(let t=0;t<H;t++){let o=j[t];if(E[G++]=o.x,E[G++]=o.y,E[G++]=o.z,e.st){if(P(r)&&r.positions.length===H)B[V++]=r.positions[t].x,B[V++]=r.positions[t].y;else{let t=i(w.multiplyByVector(_,o,v),A);f.subtract(t,L,t);let e=T.clamp(t.x/n.width,0,1),r=T.clamp(t.y/n.height,0,1);B[V++]=e,B[V++]=r}}e.normal&&(R[N++]=s.x,R[N++]=s.y,R[N++]=s.z),e.tangent&&(C[U++]=h.x,C[U++]=h.y,C[U++]=h.z),e.bitangent&&(Y[S++]=k.x,Y[S++]=k.y,Y[S++]=k.z)}let K=new p;return e.position&&(K.position=new m({componentDatatype:g.DOUBLE,componentsPerAttribute:3,values:E})),e.normal&&(K.normal=new m({componentDatatype:g.FLOAT,componentsPerAttribute:3,values:R})),e.tangent&&(K.tangent=new m({componentDatatype:g.FLOAT,componentsPerAttribute:3,values:C})),e.bitangent&&(K.bitangent=new m({componentDatatype:g.FLOAT,componentsPerAttribute:3,values:Y})),e.st&&(K.st=new m({componentDatatype:g.FLOAT,componentsPerAttribute:2,values:B})),new u({attributes:K,indices:F,primitiveType:l.TRIANGLES})}(Z[t],i,W,j,B?z[t]:void 0,M,N,S,U)});q.push(e)}let $=r.combineInstances(q)[0];$.attributes.position.values=new Float64Array($.attributes.position.values),$.indices=c.createTypedArray($.attributes.position.values.length/3,$.indices);let tt=$.attributes;return i.position||delete tt.position,new u({attributes:tt,indices:$.indices,primitiveType:$.primitiveType,boundingSphere:X})};var U=function(t,e){return P(e)&&(t=B.unpack(t,e)),B.createGeometry(t)};export{U as default};