import{a as e}from"./chunk-HJ6M6NKU.js";import{a as t}from"./chunk-4KTYBIT7.js";import{a as r}from"./chunk-XTBKSAXL.js";import"./chunk-F27AWPUY.js";import{a as o}from"./chunk-PJSC3CZC.js";import{a as n}from"./chunk-VKBMYYL4.js";import"./chunk-MQ2J7IEP.js";import"./chunk-LHHREGTA.js";import"./chunk-O2LOQWK4.js";import{a as a}from"./chunk-I4PVU2XE.js";import{a as i}from"./chunk-TMRGWDA2.js";import{a as s,b as l,c as c,d as p}from"./chunk-OST65WKL.js";import{d as h}from"./chunk-KLPRJ6SC.js";import"./chunk-4PT23TTH.js";import{a as u}from"./chunk-J4RA3VLE.js";import{a as m,d as d,f as f}from"./chunk-I4JBCTLR.js";import{a as g}from"./chunk-MCEXFPZL.js";import"./chunk-5IUKPU5Q.js";import"./chunk-B3NSNNUV.js";import{a as k}from"./chunk-BOXFFUY5.js";import{e as y}from"./chunk-OVZZEY7C.js";var w=[];function _(r){let n=(r=r??f.EMPTY_OBJECT).positions,a=r.colors,i=r.width??1,s=r.colorsPerVertex??!1;if(!y(n)||n.length<2)throw new k("At least two positions are required.");if("number"!=typeof i)throw new k("width must be a number");if(y(a)&&(s&&a.length<n.length||!s&&a.length<n.length-1))throw new k("colors has an invalid length.");this._positions=n,this._colors=a,this._width=i,this._colorsPerVertex=s,this._vertexFormat=o.clone(r.vertexFormat??o.DEFAULT),this._arcType=r.arcType??t.GEODESIC,this._granularity=r.granularity??g.RADIANS_PER_DEGREE,this._ellipsoid=d.clone(r.ellipsoid??d.default),this._workerName="createPolylineGeometry";let l=1+n.length*m.packedLength;l+=y(a)?1+a.length*e.packedLength:1,this.packedLength=l+d.packedLength+o.packedLength+4}_.pack=function(t,r,n){if(!y(t))throw new k("value is required");if(!y(r))throw new k("array is required");n=n??0;let a,i=t._positions,s=i.length;for(r[n++]=s,a=0;a<s;++a,n+=m.packedLength)m.pack(i[a],r,n);let l=t._colors;for(s=y(l)?l.length:0,r[n++]=s,a=0;a<s;++a,n+=e.packedLength)e.pack(l[a],r,n);return d.pack(t._ellipsoid,r,n),n+=d.packedLength,o.pack(t._vertexFormat,r,n),n+=o.packedLength,r[n++]=t._width,r[n++]=t._colorsPerVertex?1:0,r[n++]=t._arcType,r[n]=t._granularity,r};var L=d.clone(d.UNIT_SPHERE),T=new o,A={positions:void 0,colors:void 0,ellipsoid:L,vertexFormat:T,width:void 0,colorsPerVertex:void 0,arcType:void 0,granularity:void 0};_.unpack=function(t,r,n){if(!y(t))throw new k("array is required");r=r??0;let a,i=t[r++],s=Array(i);for(a=0;a<i;++a,r+=m.packedLength)s[a]=m.unpack(t,r);let l=(i=t[r++])>0?Array(i):void 0;for(a=0;a<i;++a,r+=e.packedLength)l[a]=e.unpack(t,r);let c=d.unpack(t,r,L);r+=d.packedLength;let p=o.unpack(t,r,T);r+=o.packedLength;let h=t[r++],u=1===t[r++],f=t[r++],g=t[r];return y(n)?(n._positions=s,n._colors=l,n._ellipsoid=d.clone(c,n._ellipsoid),n._vertexFormat=o.clone(p,n._vertexFormat),n._width=h,n._colorsPerVertex=u,n._arcType=f,n._granularity=g,n):(A.positions=s,A.colors=l,A.width=h,A.colorsPerVertex=u,A.arcType=f,A.granularity=g,new _(A))};var E=new m,P=new m,v=new m,b=new m;_.createGeometry=function(o){let d=o._width,f=o._vertexFormat,k=o._colors,_=o._colorsPerVertex,L=o._arcType,T=o._granularity,A=o._ellipsoid,j,x,D,F=[],O=n(o._positions,m.equalsEpsilon,!1,F);if(y(k)&&F.length>0){let e=0,t=F[0];k=k.filter(function(r,o){return!(_?o===t||0===o&&1===t:o+1===t)||(t=F[++e],!1)})}let B=O.length;if(B<2||d<=0)return;if(L===t.GEODESIC||L===t.RHUMB){let o,n;L===t.GEODESIC?(o=g.chordLength(T,A.maximumRadius),n=r.numberOfPoints):(o=T,n=r.numberOfPointsRhumbLine);let a=r.extractHeights(O,A);if(y(k)){let t=1;for(j=0;j<B-1;++j)t+=n(O[j],O[j+1],o);let r=Array(t),a=0;for(j=0;j<B-1;++j){let i=O[j],s=O[j+1],l=k[j],c=n(i,s,o);if(_&&j<t){let t=function(t,r,o,n,a){w.length=a;let i,s=o.red,l=o.green,c=o.blue,p=o.alpha,h=n.red,u=n.green,m=n.blue,d=n.alpha;if(e.equals(o,n)){for(i=0;i<a;i++)w[i]=e.clone(o);return w}let f=(h-s)/a,g=(u-l)/a,k=(m-c)/a,y=(d-p)/a;for(i=0;i<a;i++)w[i]=new e(s+i*f,l+i*g,c+i*k,p+i*y);return w}(0,0,l,k[j+1],c),o=t.length;for(x=0;x<o;++x)r[a++]=t[x]}else for(x=0;x<c;++x)r[a++]=e.clone(l)}r[a]=e.clone(k[k.length-1]),k=r,w.length=0}O=L===t.GEODESIC?r.generateCartesianArc({positions:O,minDistance:o,ellipsoid:A,height:a}):r.generateCartesianRhumbArc({positions:O,granularity:o,ellipsoid:A,height:a})}let S=4*(B=O.length)-4,U=new Float64Array(3*S),C=new Float64Array(3*S),I=new Float64Array(3*S),R=new Float32Array(2*S),G=f.st?new Float32Array(2*S):void 0,V=y(k)?new Uint8Array(4*S):void 0,N=0,Y=0,K=0,M=0,H;for(x=0;x<B;++x){let t,r;0===x?(H=E,m.subtract(O[0],O[1],H),m.add(O[0],H,H)):H=O[x-1],m.clone(H,v),m.clone(O[x],P),x===B-1?(H=E,m.subtract(O[B-1],O[B-2],H),m.add(O[B-1],H,H)):H=O[x+1],m.clone(H,b),y(V)&&(t=0===x||_?k[x]:k[x-1],x!==B-1&&(r=k[x]));let o=0===x?2:0,n=x===B-1?2:4;for(D=o;D<n;++D){m.pack(P,U,N),m.pack(v,C,N),m.pack(b,I,N),N+=3;let o=D-2<0?-1:1;if(R[Y++]=D%2*2-1,R[Y++]=o*d,f.st&&(G[K++]=x/(B-1),G[K++]=Math.max(R[Y-2],0)),y(V)){let o=D<2?t:r;V[M++]=e.floatToByte(o.red),V[M++]=e.floatToByte(o.green),V[M++]=e.floatToByte(o.blue),V[M++]=e.floatToByte(o.alpha)}}}let J=new i;J.position=new p({componentDatatype:u.DOUBLE,componentsPerAttribute:3,values:U}),J.prevPosition=new p({componentDatatype:u.DOUBLE,componentsPerAttribute:3,values:C}),J.nextPosition=new p({componentDatatype:u.DOUBLE,componentsPerAttribute:3,values:I}),J.expandAndWidth=new p({componentDatatype:u.FLOAT,componentsPerAttribute:2,values:R}),f.st&&(J.st=new p({componentDatatype:u.FLOAT,componentsPerAttribute:2,values:G})),y(V)&&(J.color=new p({componentDatatype:u.UNSIGNED_BYTE,componentsPerAttribute:4,values:V,normalize:!0}));let q=a.createTypedArray(S,6*B-6),W=0,X=0,Z=B-1;for(x=0;x<Z;++x)q[X++]=W,q[X++]=W+2,q[X++]=W+1,q[X++]=W+1,q[X++]=W+2,q[X++]=W+3,W+=4;return new c({attributes:J,indices:q,primitiveType:l.TRIANGLES,boundingSphere:h.fromPoints(O),geometryType:s.POLYLINES})};var j=function(e,t){return y(t)&&(e=_.unpack(e,t)),e._ellipsoid=d.clone(e._ellipsoid),_.createGeometry(e)};export{j as default};