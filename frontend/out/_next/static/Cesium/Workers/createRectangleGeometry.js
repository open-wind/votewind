import{a as t}from"./chunk-PCP6Y43Y.js";import{a as e}from"./chunk-PYEWQREH.js";import{a as n}from"./chunk-7Q53UG4E.js";import"./chunk-OFGHX2F3.js";import"./chunk-GT4KWHVH.js";import{a as o}from"./chunk-HNJRTQHB.js";import{a as a}from"./chunk-PJSC3CZC.js";import{b as r}from"./chunk-AKNTYFRF.js";import"./chunk-MQ2J7IEP.js";import"./chunk-LHHREGTA.js";import"./chunk-O2LOQWK4.js";import{a as i}from"./chunk-I4PVU2XE.js";import{a as s}from"./chunk-TMRGWDA2.js";import{b as l,c as u,d as c}from"./chunk-OST65WKL.js";import{d as m}from"./chunk-KLPRJ6SC.js";import{f as p,h as h,i as g}from"./chunk-4PT23TTH.js";import{a as f}from"./chunk-J4RA3VLE.js";import{a as d,b as _,c as y,d as b,e as w,f as A}from"./chunk-I4JBCTLR.js";import{a as v}from"./chunk-MCEXFPZL.js";import"./chunk-5IUKPU5Q.js";import"./chunk-B3NSNNUV.js";import{a as x,b as E}from"./chunk-BOXFFUY5.js";import{e as P}from"./chunk-OVZZEY7C.js";var k=new d,F=new d,R=new d,T=new d,L=new h,O=new y,N=new m,j=new m;function D(t,e){let n=new u({attributes:new s,primitiveType:l.TRIANGLES});return n.attributes.position=new c({componentDatatype:f.DOUBLE,componentsPerAttribute:3,values:e.positions}),t.normal&&(n.attributes.normal=new c({componentDatatype:f.FLOAT,componentsPerAttribute:3,values:e.normals})),t.tangent&&(n.attributes.tangent=new c({componentDatatype:f.FLOAT,componentsPerAttribute:3,values:e.tangents})),t.bitangent&&(n.attributes.bitangent=new c({componentDatatype:f.FLOAT,componentsPerAttribute:3,values:e.bitangents})),n}var H=new d,S=new d;function I(e,n){let o=e._vertexFormat,a=e._ellipsoid,r=n.height,s=n.width,l=n.northCap,u=n.southCap,m=0,p=r,h=r,g=0;l&&(m=1,h-=1,g+=1),u&&(p-=1,h-=1,g+=1),g+=s*h;let _=o.position?new Float64Array(3*g):void 0,y=o.st?new Float32Array(2*g):void 0,b=0,A=0,v=Number.MAX_VALUE,x=Number.MAX_VALUE,E=-Number.MAX_VALUE,P=-Number.MAX_VALUE;for(let e=m;e<p;++e)for(let r=0;r<s;++r)t.computePosition(n,a,o.st,e,r,k,O),_[b++]=k.x,_[b++]=k.y,_[b++]=k.z,o.st&&(y[A++]=O.x,y[A++]=O.y,v=Math.min(v,O.x),x=Math.min(x,O.y),E=Math.max(E,O.x),P=Math.max(P,O.y));if(l&&(t.computePosition(n,a,o.st,0,0,k,O),_[b++]=k.x,_[b++]=k.y,_[b++]=k.z,o.st&&(y[A++]=O.x,y[A++]=O.y,v=O.x,x=O.y,E=O.x,P=O.y)),u&&(t.computePosition(n,a,o.st,r-1,0,k,O),_[b++]=k.x,_[b++]=k.y,_[b]=k.z,o.st&&(y[A++]=O.x,y[A]=O.y,v=Math.min(v,O.x),x=Math.min(x,O.y),E=Math.max(E,O.x),P=Math.max(P,O.y))),o.st&&(v<0||x<0||E>1||P>1))for(let t=0;t<y.length;t+=2)y[t]=(y[t]-v)/(E-v),y[t+1]=(y[t+1]-x)/(P-x);let L=function(t,e,n,o){let a=t.length,r=e.normal?new Float32Array(a):void 0,i=e.tangent?new Float32Array(a):void 0,s=e.bitangent?new Float32Array(a):void 0,l=0,u=F;if(e.normal||e.tangent||e.bitangent)for(let c=0;c<a;c+=3){let a=d.fromArray(t,c,k),m=l+1,p=l+2;u=n.geodeticSurfaceNormal(a,u),(e.tangent||e.bitangent)&&(d.cross(d.UNIT_Z,u,R),w.multiplyByVector(o,R,R),d.normalize(R,R),e.bitangent&&d.normalize(d.cross(u,R,T),T)),e.normal&&(r[l]=u.x,r[m]=u.y,r[p]=u.z),e.tangent&&(i[l]=R.x,i[m]=R.y,i[p]=R.z),e.bitangent&&(s[l]=T.x,s[m]=T.y,s[p]=T.z),l+=3}return D(e,{positions:t,normals:r,tangents:i,bitangents:s})}(_,o,a,n.tangentRotationMatrix),N=6*(s-1)*(h-1);l&&(N+=3*(s-1)),u&&(N+=3*(s-1));let j=i.createTypedArray(g,N),H=0,S=0,I;for(I=0;I<h-1;++I){for(let t=0;t<s-1;++t){let t=H,e=t+s,n=e+1,o=t+1;j[S++]=t,j[S++]=e,j[S++]=o,j[S++]=o,j[S++]=e,j[S++]=n,++H}++H}if(l||u){let t,e,n=g-1,o=g-1;if(l&&u&&(n=g-2),H=0,l)for(I=0;I<s-1;I++)e=(t=H)+1,j[S++]=n,j[S++]=t,j[S++]=e,++H;if(u)for(H=(h-1)*s,I=0;I<s-1;I++)e=(t=H)+1,j[S++]=t,j[S++]=o,j[S++]=e,++H}return L.indices=j,o.st&&(L.attributes.st=new c({componentDatatype:f.FLOAT,componentsPerAttribute:2,values:y})),L}function C(t,e,n,o,a){return t[e++]=o[n],t[e++]=o[n+1],t[e++]=o[n+2],t[e++]=a[n],t[e++]=a[n+1],t[e]=a[n+2],t}function M(t,e,n,o){return t[e++]=o[n],t[e++]=o[n+1],t[e++]=o[n],t[e]=o[n+1],t}var U=new a,V=[new d,new d,new d,new d],G=new _,z=new _;function Y(e,n,o,a,r){if(0===o)return h.clone(e,r);let i=t.computeOptions(e,n,o,0,L,G),s=i.height,l=i.width;return t.computePosition(i,a,!1,0,0,V[0]),t.computePosition(i,a,!1,0,l-1,V[1]),t.computePosition(i,a,!1,s-1,0,V[2]),t.computePosition(i,a,!1,s-1,l-1,V[3]),h.fromCartesianArray(V,a,r)}function B(t){let e=(t=t??A.EMPTY_OBJECT).rectangle;if(E.typeOf.object("rectangle",e),h._validate(e),e.north<e.south)throw new x("options.rectangle.north must be greater than or equal to options.rectangle.south");let n=t.height??0,o=t.extrudedHeight??n;this._rectangle=h.clone(e),this._granularity=t.granularity??v.RADIANS_PER_DEGREE,this._ellipsoid=b.clone(t.ellipsoid??b.default),this._surfaceHeight=Math.max(n,o),this._rotation=t.rotation??0,this._stRotation=t.stRotation??0,this._vertexFormat=a.clone(t.vertexFormat??a.DEFAULT),this._extrudedHeight=Math.min(n,o),this._shadowVolume=t.shadowVolume??!1,this._workerName="createRectangleGeometry",this._offsetAttribute=t.offsetAttribute,this._rotatedRectangle=void 0,this._textureCoordinateRotationPoints=void 0}B.packedLength=h.packedLength+b.packedLength+a.packedLength+7,B.pack=function(t,e,n){return E.typeOf.object("value",t),E.defined("array",e),n=n??0,h.pack(t._rectangle,e,n),n+=h.packedLength,b.pack(t._ellipsoid,e,n),n+=b.packedLength,a.pack(t._vertexFormat,e,n),n+=a.packedLength,e[n++]=t._granularity,e[n++]=t._surfaceHeight,e[n++]=t._rotation,e[n++]=t._stRotation,e[n++]=t._extrudedHeight,e[n++]=t._shadowVolume?1:0,e[n]=t._offsetAttribute??-1,e};var J=new h,X=b.clone(b.UNIT_SPHERE),q={rectangle:J,ellipsoid:X,vertexFormat:U,granularity:void 0,height:void 0,rotation:void 0,stRotation:void 0,extrudedHeight:void 0,shadowVolume:void 0,offsetAttribute:void 0};B.unpack=function(t,e,n){E.defined("array",t),e=e??0;let o=h.unpack(t,e,J);e+=h.packedLength;let r=b.unpack(t,e,X);e+=b.packedLength;let i=a.unpack(t,e,U);e+=a.packedLength;let s=t[e++],l=t[e++],u=t[e++],c=t[e++],m=t[e++],p=1===t[e++],g=t[e];return P(n)?(n._rectangle=h.clone(o,n._rectangle),n._ellipsoid=b.clone(r,n._ellipsoid),n._vertexFormat=a.clone(i,n._vertexFormat),n._granularity=s,n._surfaceHeight=l,n._rotation=u,n._stRotation=c,n._extrudedHeight=m,n._shadowVolume=p,n._offsetAttribute=-1===g?void 0:g,n):(q.granularity=s,q.height=l,q.rotation=u,q.stRotation=c,q.extrudedHeight=m,q.shadowVolume=p,q.offsetAttribute=-1===g?void 0:g,new B(q))},B.computeRectangle=function(t,e){let n=(t=t??A.EMPTY_OBJECT).rectangle;if(E.typeOf.object("rectangle",n),h._validate(n),n.north<n.south)throw new x("options.rectangle.north must be greater than or equal to options.rectangle.south");let o=t.granularity??v.RADIANS_PER_DEGREE,a=t.ellipsoid??b.default;return Y(n,o,t.rotation??0,a,e)};var Q=new w,K=new p,W=new _;B.createGeometry=function(s){let l,g;if(v.equalsEpsilon(s._rectangle.north,s._rectangle.south,v.EPSILON10)||v.equalsEpsilon(s._rectangle.east,s._rectangle.west,v.EPSILON10))return;let _=s._rectangle,y=s._ellipsoid,b=s._rotation,A=s._stRotation,x=s._vertexFormat,E=t.computeOptions(_,s._granularity,b,A,L,G,z);if(0!==A||0!==b){let t=h.center(_,W),e=y.geodeticSurfaceNormalCartographic(t,H);p.fromAxisAngle(e,-A,K),w.fromQuaternion(K,Q)}else w.clone(w.IDENTITY,Q);let O=s._surfaceHeight,V=s._extrudedHeight,Y=!v.equalsEpsilon(O,V,0,v.EPSILON2);if(E.lonScalar=1/s._rectangle.width,E.latScalar=1/s._rectangle.height,E.tangentRotationMatrix=Q,_=s._rectangle,Y){l=function(t,s){let l=t._shadowVolume,u=t._offsetAttribute,m=t._vertexFormat,p=t._extrudedHeight,h=t._surfaceHeight,g=t._ellipsoid,_=s.height,y=s.width,b;if(l){let e=a.clone(m,U);e.normal=!0,t._vertexFormat=e}let w=I(t,s);l&&(t._vertexFormat=m);let A=r.scaleToGeodeticHeight(w.attributes.position.values,h,g,!1),x=(A=new Float64Array(A)).length,E=2*x,L=new Float64Array(E);L.set(A);let O=r.scaleToGeodeticHeight(w.attributes.position.values,p,g);L.set(O,x),w.attributes.position.values=L;let N=m.normal?new Float32Array(E):void 0,j=m.tangent?new Float32Array(E):void 0,V=m.bitangent?new Float32Array(E):void 0,G=m.st?new Float32Array(E/3*2):void 0,z,Y;if(m.normal){for(Y=w.attributes.normal.values,N.set(Y),b=0;b<x;b++)Y[b]=-Y[b];N.set(Y,x),w.attributes.normal.values=N}if(l){Y=w.attributes.normal.values,m.normal||(w.attributes.normal=void 0);let t=new Float32Array(E);for(b=0;b<x;b++)Y[b]=-Y[b];t.set(Y,x),w.attributes.extrudeDirection=new c({componentDatatype:f.FLOAT,componentsPerAttribute:3,values:t})}let B,J=P(u);if(J){let t=x/3*2,e=new Uint8Array(t);u===o.TOP?e=e.fill(1,0,t/2):(B=u===o.NONE?0:1,e=e.fill(B)),w.attributes.applyOffset=new c({componentDatatype:f.UNSIGNED_BYTE,componentsPerAttribute:1,values:e})}if(m.tangent){let t=w.attributes.tangent.values;for(j.set(t),b=0;b<x;b++)t[b]=-t[b];j.set(t,x),w.attributes.tangent.values=j}if(m.bitangent){let t=w.attributes.bitangent.values;V.set(t),V.set(t,x),w.attributes.bitangent.values=V}m.st&&(z=w.attributes.st.values,G.set(z),G.set(z,x/3*2),w.attributes.st.values=G);let X=w.indices,q=X.length,Q=x/3,K=i.createTypedArray(E/3,2*q);for(K.set(X),b=0;b<q;b+=3)K[b+q]=X[b+2]+Q,K[b+1+q]=X[b+1]+Q,K[b+2+q]=X[b]+Q;w.indices=K;let W=s.northCap,Z=s.southCap,$=_,tt=2,te=0,tn=4,to=4;W&&(tt-=1,$-=1,te+=1,tn-=2,to-=1),Z&&(tt-=1,$-=1,te+=1,tn-=2,to-=1);let ta=((te+=tt*y+2*$-tn)+to)*2,tr=new Float64Array(3*ta),ti=l?new Float32Array(3*ta):void 0,ts=J?new Uint8Array(ta):void 0,tl=m.st?new Float32Array(2*ta):void 0,tu=u===o.TOP;J&&!tu&&(B=u===o.ALL?1:0,ts=ts.fill(B));let tc=0,tm=0,tp=0,th=0,tg=y*$,tf;for(b=0;b<tg;b+=y)tr=C(tr,tc,tf=3*b,A,O),tc+=6,m.st&&(tl=M(tl,tm,2*b,z),tm+=4),l&&(tp+=3,ti[tp++]=Y[tf],ti[tp++]=Y[tf+1],ti[tp++]=Y[tf+2]),tu&&(ts[th++]=1,th+=1);if(Z){let t=W?tg+1:tg;for(tf=3*t,b=0;b<2;b++)tr=C(tr,tc,tf,A,O),tc+=6,m.st&&(tl=M(tl,tm,2*t,z),tm+=4),l&&(tp+=3,ti[tp++]=Y[tf],ti[tp++]=Y[tf+1],ti[tp++]=Y[tf+2]),tu&&(ts[th++]=1,th+=1)}else for(b=tg-y;b<tg;b++)tr=C(tr,tc,tf=3*b,A,O),tc+=6,m.st&&(tl=M(tl,tm,2*b,z),tm+=4),l&&(tp+=3,ti[tp++]=Y[tf],ti[tp++]=Y[tf+1],ti[tp++]=Y[tf+2]),tu&&(ts[th++]=1,th+=1);for(b=tg-1;b>0;b-=y)tr=C(tr,tc,tf=3*b,A,O),tc+=6,m.st&&(tl=M(tl,tm,2*b,z),tm+=4),l&&(tp+=3,ti[tp++]=Y[tf],ti[tp++]=Y[tf+1],ti[tp++]=Y[tf+2]),tu&&(ts[th++]=1,th+=1);if(W)for(tf=3*tg,b=0;b<2;b++)tr=C(tr,tc,tf,A,O),tc+=6,m.st&&(tl=M(tl,tm,2*tg,z),tm+=4),l&&(tp+=3,ti[tp++]=Y[tf],ti[tp++]=Y[tf+1],ti[tp++]=Y[tf+2]),tu&&(ts[th++]=1,th+=1);else for(b=y-1;b>=0;b--)tr=C(tr,tc,tf=3*b,A,O),tc+=6,m.st&&(tl=M(tl,tm,2*b,z),tm+=4),l&&(tp+=3,ti[tp++]=Y[tf],ti[tp++]=Y[tf+1],ti[tp++]=Y[tf+2]),tu&&(ts[th++]=1,th+=1);let td=function(t,e,n){let o=t.length,a=e.normal?new Float32Array(o):void 0,r=e.tangent?new Float32Array(o):void 0,i=e.bitangent?new Float32Array(o):void 0,s=0,l=0,u=0,c=!0,m=T,p=R,h=F;if(e.normal||e.tangent||e.bitangent)for(let g=0;g<o;g+=6){let f=d.fromArray(t,g,k),_=d.fromArray(t,(g+6)%o,H);if(c){let e=d.fromArray(t,(g+3)%o,S);d.subtract(_,f,_),d.subtract(e,f,e),h=d.normalize(d.cross(e,_,h),h),c=!1}d.equalsEpsilon(_,f,v.EPSILON10)&&(c=!0),(e.tangent||e.bitangent)&&(m=n.geodeticSurfaceNormal(f,m),e.tangent&&(p=d.normalize(d.cross(m,h,p),p))),e.normal&&(a[s++]=h.x,a[s++]=h.y,a[s++]=h.z,a[s++]=h.x,a[s++]=h.y,a[s++]=h.z),e.tangent&&(r[l++]=p.x,r[l++]=p.y,r[l++]=p.z,r[l++]=p.x,r[l++]=p.y,r[l++]=p.z),e.bitangent&&(i[u++]=m.x,i[u++]=m.y,i[u++]=m.z,i[u++]=m.x,i[u++]=m.y,i[u++]=m.z)}return D(e,{positions:t,normals:a,tangents:r,bitangents:i})}(tr,m,g);m.st&&(td.attributes.st=new c({componentDatatype:f.FLOAT,componentsPerAttribute:2,values:tl})),l&&(td.attributes.extrudeDirection=new c({componentDatatype:f.FLOAT,componentsPerAttribute:3,values:ti})),J&&(td.attributes.applyOffset=new c({componentDatatype:f.UNSIGNED_BYTE,componentsPerAttribute:1,values:ts}));let t_=i.createTypedArray(ta,6*te),ty,tb,tw,tA;x=tr.length/3;let tv=0;for(b=0;b<x-1;b+=2){tA=((ty=b)+2)%x;let t=d.fromArray(tr,3*ty,H),e=d.fromArray(tr,3*tA,S);d.equalsEpsilon(t,e,v.EPSILON10)||(tw=((tb=(ty+1)%x)+2)%x,t_[tv++]=ty,t_[tv++]=tb,t_[tv++]=tA,t_[tv++]=tA,t_[tv++]=tb,t_[tv++]=tw)}return td.indices=t_,(td=n.combineInstances([new e({geometry:w}),new e({geometry:td})]))[0]}(s,E);let t=m.fromRectangle3D(_,y,O,j),u=m.fromRectangle3D(_,y,V,N);g=m.union(t,u)}else{if((l=I(s,E)).attributes.position.values=r.scaleToGeodeticHeight(l.attributes.position.values,O,y,!1),P(s._offsetAttribute)){let t=l.attributes.position.values.length,e=s._offsetAttribute===o.NONE?0:1,n=new Uint8Array(t/3).fill(e);l.attributes.applyOffset=new c({componentDatatype:f.UNSIGNED_BYTE,componentsPerAttribute:1,values:n})}g=m.fromRectangle3D(_,y,O)}return x.position||delete l.attributes.position,new u({attributes:l.attributes,indices:l.indices,primitiveType:l.primitiveType,boundingSphere:g,offsetAttribute:s._offsetAttribute})},B.createShadowVolume=function(t,e,n){let o=t._granularity,r=t._ellipsoid,i=e(o,r),s=n(o,r);return new B({rectangle:t._rectangle,rotation:t._rotation,ellipsoid:r,stRotation:t._stRotation,granularity:o,extrudedHeight:s,height:i,vertexFormat:a.POSITION_ONLY,shadowVolume:!0})};var Z=new h,$=[new y,new y,new y],tt=new g,te=new _;Object.defineProperties(B.prototype,{rectangle:{get:function(){return P(this._rotatedRectangle)||(this._rotatedRectangle=Y(this._rectangle,this._granularity,this._rotation,this._ellipsoid)),this._rotatedRectangle}},textureCoordinateRotationPoints:{get:function(){return P(this._textureCoordinateRotationPoints)||(this._textureCoordinateRotationPoints=function(t){if(0===t._stRotation)return[0,0,0,1,1,0];let e=h.clone(t._rectangle,Z),n=t._granularity,o=t._ellipsoid,a=Y(e,n,t._rotation-t._stRotation,o,Z);$[0].x=a.west,$[0].y=a.south,$[1].x=a.west,$[1].y=a.north,$[2].x=a.east,$[2].y=a.south;let r=t.rectangle,i=g.fromRotation(t._stRotation,tt),s=h.center(r,te);for(let t=0;t<3;++t){let e=$[t];e.x-=s.longitude,e.y-=s.latitude,g.multiplyByVector(i,e,e),e.x+=s.longitude,e.y+=s.latitude,e.x=(e.x-r.west)/r.width,e.y=(e.y-r.south)/r.height}let l=$[0],u=$[1],c=$[2],m=Array(6);return y.pack(l,m),y.pack(u,m,2),y.pack(c,m,4),m}(this)),this._textureCoordinateRotationPoints}}});var tn=function(t,e){return P(e)&&(t=B.unpack(t,e)),t._ellipsoid=b.clone(t._ellipsoid),t._rectangle=h.clone(t._rectangle),B.createGeometry(t)};export{tn as default};