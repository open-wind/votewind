import{a as t}from"./chunk-YL52S4YJ.js";import{a as e}from"./chunk-YUGVMPE3.js";import"./chunk-XTBKSAXL.js";import"./chunk-F27AWPUY.js";import{a as r}from"./chunk-HNJRTQHB.js";import{a as o}from"./chunk-PJSC3CZC.js";import"./chunk-VRX6MZUH.js";import"./chunk-EMIRY7IE.js";import{b as i}from"./chunk-AKNTYFRF.js";import{a as a}from"./chunk-VKBMYYL4.js";import"./chunk-MQ2J7IEP.js";import"./chunk-LHHREGTA.js";import"./chunk-O2LOQWK4.js";import{a as n}from"./chunk-I4PVU2XE.js";import{a as l}from"./chunk-TMRGWDA2.js";import{b as s,c as u,d as d}from"./chunk-OST65WKL.js";import{d as m}from"./chunk-KLPRJ6SC.js";import{h as h}from"./chunk-4PT23TTH.js";import{a as c}from"./chunk-J4RA3VLE.js";import{a as f,b as p,d as g,f as A}from"./chunk-I4JBCTLR.js";import{a as b}from"./chunk-MCEXFPZL.js";import"./chunk-5IUKPU5Q.js";import"./chunk-B3NSNNUV.js";import{b as y}from"./chunk-BOXFFUY5.js";import{e as _}from"./chunk-OVZZEY7C.js";var w=new f,v=new f,T=new f,E=new f,k=new f,N=new f,P=new f,F=new f;function I(t,e){for(let r=0;r<t.length;r++)t[r]=e.scaleToGeodeticSurface(t[r],t[r]);return t}function O(e,r,o,i,a,n){let l=e.normals,s=e.tangents,u=e.bitangents,d=f.normalize(f.cross(o,r,P),P);n.normal&&t.addAttribute(l,r,i,a),n.tangent&&t.addAttribute(s,d,i,a),n.bitangent&&t.addAttribute(u,o,i,a)}function M(e,r,o){let i,a,s=e.positions,u=e.corners,m=e.endPositions,h=e.lefts,p=e.normals,g=new l,A,y=0,k=0,I,M=0,x;for(I=0;I<s.length;I+=2)y+=x=s[I].length-3,M+=2*x,k+=s[I+1].length-3;for(y+=3,k+=3,I=0;I<u.length;I++){A=u[I];let t=u[I].leftPositions;_(t)?y+=x=t.length:k+=x=u[I].rightPositions.length,M+=x}let L=_(m),S;L&&(y+=S=m[0].length-3,k+=S,S/=3,M+=6*S);let V=y+k,j=new Float64Array(V),D={normals:r.normal?new Float32Array(V):void 0,tangents:r.tangent?new Float32Array(V):void 0,bitangents:r.bitangent?new Float32Array(V):void 0},R=0,H=V-1,U,Y,G,C,B=w,z=v,J,W,K=S/2,X=n.createTypedArray(V/3,M),Z=0;if(L){W=T,J=E;let e=m[0];for(B=f.fromArray(p,0,B),z=f.fromArray(h,0,z),I=0;I<K;I++)W=f.fromArray(e,(K-1-I)*3,W),J=f.fromArray(e,(K+I)*3,J),t.addAttribute(j,J,R),t.addAttribute(j,W,void 0,H),O(D,B,z,R,H,r),C=(Y=R/3)+1,G=(U=(H-2)/3)-1,X[Z++]=U,X[Z++]=Y,X[Z++]=G,X[Z++]=G,X[Z++]=Y,X[Z++]=C,R+=3,H-=3}let Q=0,q=0,$=s[Q++],tt=s[Q++];for(j.set($,R),j.set(tt,H-tt.length+1),z=f.fromArray(h,q,z),x=tt.length-3,I=0;I<x;I+=3)i=o.geodeticSurfaceNormal(f.fromArray($,I,P),P),a=o.geodeticSurfaceNormal(f.fromArray(tt,x-I,F),F),O(D,B=f.normalize(f.add(i,a,B),B),z,R,H,r),C=(Y=R/3)+1,G=(U=(H-2)/3)-1,X[Z++]=U,X[Z++]=Y,X[Z++]=G,X[Z++]=G,X[Z++]=Y,X[Z++]=C,R+=3,H-=3;for(i=o.geodeticSurfaceNormal(f.fromArray($,x,P),P),a=o.geodeticSurfaceNormal(f.fromArray(tt,x,F),F),B=f.normalize(f.add(i,a,B),B),q+=3,I=0;I<u.length;I++){let e;let n=(A=u[I]).leftPositions,l=A.rightPositions,d,m,c=N,g=T,b=E;if(B=f.fromArray(p,q,B),_(n)){for(O(D,B,z,void 0,H,r),H-=3,d=C,m=G,e=0;e<n.length/3;e++)c=f.fromArray(n,3*e,c),X[Z++]=d,X[Z++]=m-e-1,X[Z++]=m-e,t.addAttribute(j,c,void 0,H),g=f.fromArray(j,(m-e-1)*3,g),b=f.fromArray(j,3*d,b),O(D,B,z=f.normalize(f.subtract(g,b,z),z),void 0,H,r),H-=3;c=f.fromArray(j,3*d,c),g=f.subtract(f.fromArray(j,3*m,g),c,g),b=f.subtract(f.fromArray(j,(m-e)*3,b),c,b),O(D,B,z=f.normalize(f.add(g,b,z),z),R,void 0,r),R+=3}else{for(O(D,B,z,R,void 0,r),R+=3,d=G,m=C,e=0;e<l.length/3;e++)c=f.fromArray(l,3*e,c),X[Z++]=d,X[Z++]=m+e,X[Z++]=m+e+1,t.addAttribute(j,c,R),g=f.fromArray(j,3*d,g),b=f.fromArray(j,(m+e)*3,b),O(D,B,z=f.normalize(f.subtract(g,b,z),z),R,void 0,r),R+=3;c=f.fromArray(j,3*d,c),g=f.subtract(f.fromArray(j,(m+e)*3,g),c,g),b=f.subtract(f.fromArray(j,3*m,b),c,b),O(D,B,z=f.normalize(f.negate(f.add(b,g,z),z),z),void 0,H,r),H-=3}for($=s[Q++],tt=s[Q++],$.splice(0,3),tt.splice(tt.length-3,3),j.set($,R),j.set(tt,H-tt.length+1),x=tt.length-3,q+=3,z=f.fromArray(h,q,z),e=0;e<tt.length;e+=3)i=o.geodeticSurfaceNormal(f.fromArray($,e,P),P),a=o.geodeticSurfaceNormal(f.fromArray(tt,x-e,F),F),O(D,B=f.normalize(f.add(i,a,B),B),z,R,H,r),Y=(C=R/3)-1,U=(G=(H-2)/3)+1,X[Z++]=U,X[Z++]=Y,X[Z++]=G,X[Z++]=G,X[Z++]=Y,X[Z++]=C,R+=3,H-=3;R-=3,H+=3}if(O(D,B=f.fromArray(p,p.length-3,B),z,R,H,r),L){R+=3,H-=3,W=T,J=E;let e=m[1];for(I=0;I<K;I++)W=f.fromArray(e,(S-I-1)*3,W),J=f.fromArray(e,3*I,J),t.addAttribute(j,W,void 0,H),t.addAttribute(j,J,R),O(D,B,z,R,H,r),Y=(C=R/3)-1,U=(G=(H-2)/3)+1,X[Z++]=U,X[Z++]=Y,X[Z++]=G,X[Z++]=G,X[Z++]=Y,X[Z++]=C,R+=3,H-=3}if(g.position=new d({componentDatatype:c.DOUBLE,componentsPerAttribute:3,values:j}),r.st){let t=new Float32Array(V/3*2),e,r,o=0;if(L){y/=3,k/=3;let i=Math.PI/(S+1);r=1/(y-S+1),e=1/(k-S+1);let a,n=S/2;for(I=n+1;I<S+1;I++)a=b.PI_OVER_TWO+i*I,t[o++]=e*(1+Math.cos(a)),t[o++]=.5*(1+Math.sin(a));for(I=1;I<k-S+1;I++)t[o++]=I*e,t[o++]=0;for(I=S;I>n;I--)a=b.PI_OVER_TWO-I*i,t[o++]=1-e*(1+Math.cos(a)),t[o++]=.5*(1+Math.sin(a));for(I=n;I>0;I--)a=b.PI_OVER_TWO-i*I,t[o++]=1-r*(1+Math.cos(a)),t[o++]=.5*(1+Math.sin(a));for(I=y-S;I>0;I--)t[o++]=I*r,t[o++]=1;for(I=1;I<n+1;I++)a=b.PI_OVER_TWO+i*I,t[o++]=r*(1+Math.cos(a)),t[o++]=.5*(1+Math.sin(a))}else{for(y/=3,k/=3,r=1/(y-1),e=1/(k-1),I=0;I<k;I++)t[o++]=I*e,t[o++]=0;for(I=y;I>0;I--)t[o++]=(I-1)*r,t[o++]=1}g.st=new d({componentDatatype:c.FLOAT,componentsPerAttribute:2,values:t})}return r.normal&&(g.normal=new d({componentDatatype:c.FLOAT,componentsPerAttribute:3,values:D.normals})),r.tangent&&(g.tangent=new d({componentDatatype:c.FLOAT,componentsPerAttribute:3,values:D.tangents})),r.bitangent&&(g.bitangent=new d({componentDatatype:c.FLOAT,componentsPerAttribute:3,values:D.bitangents})),{attributes:g,indices:X}}function x(t,e,r){r[e++]=t[0],r[e++]=t[1],r[e++]=t[2];for(let o=3;o<t.length;o+=3){let i=t[o],a=t[o+1],n=t[o+2];r[e++]=i,r[e++]=a,r[e++]=n,r[e++]=i,r[e++]=a,r[e++]=n}return r[e++]=t[0],r[e++]=t[1],r[e++]=t[2],r}var L=new f,S=new f,V=new p;function j(t,e,r,o,i,a){let n=f.subtract(e,t,L);f.normalize(n,n);let l=r.geodeticSurfaceNormal(t,S),s=f.cross(n,l,L);f.multiplyByScalar(s,o,s);let u=i.latitude,d=i.longitude,m=a.latitude,h=a.longitude;f.add(t,s,S),r.cartesianToCartographic(S,V);let c=V.latitude,p=V.longitude;u=Math.min(u,c),d=Math.min(d,p),m=Math.max(m,c),h=Math.max(h,p),f.subtract(t,s,S),r.cartesianToCartographic(S,V),c=V.latitude,p=V.longitude,u=Math.min(u,c),d=Math.min(d,p),m=Math.max(m,c),h=Math.max(h,p),i.latitude=u,i.longitude=d,a.latitude=m,a.longitude=h}var D=new f,R=new f,H=new p,U=new p;function Y(t,r,o,i,n){let l,s;let u=a(t=I(t,r),f.equalsEpsilon),d=u.length;if(d<2||o<=0)return new h;let m=.5*o;if(H.latitude=Number.POSITIVE_INFINITY,H.longitude=Number.POSITIVE_INFINITY,U.latitude=Number.NEGATIVE_INFINITY,U.longitude=Number.NEGATIVE_INFINITY,i===e.ROUNDED){let t=u[0];f.subtract(t,u[1],D),f.normalize(D,D),f.multiplyByScalar(D,m,D),f.add(t,D,R),r.cartesianToCartographic(R,V),l=V.latitude,s=V.longitude,H.latitude=Math.min(H.latitude,l),H.longitude=Math.min(H.longitude,s),U.latitude=Math.max(U.latitude,l),U.longitude=Math.max(U.longitude,s)}for(let t=0;t<d-1;++t)j(u[t],u[t+1],r,m,H,U);let c=u[d-1];f.subtract(c,u[d-2],D),f.normalize(D,D),f.multiplyByScalar(D,m,D),f.add(c,D,R),j(c,R,r,m,H,U),i===e.ROUNDED&&(r.cartesianToCartographic(R,V),l=V.latitude,s=V.longitude,H.latitude=Math.min(H.latitude,l),H.longitude=Math.min(H.longitude,s),U.latitude=Math.max(U.latitude,l),U.longitude=Math.max(U.longitude,s));let p=_(n)?n:new h;return p.north=U.latitude,p.south=H.latitude,p.east=U.longitude,p.west=H.longitude,p}function G(t){let r=(t=t??A.EMPTY_OBJECT).positions,i=t.width;y.defined("options.positions",r),y.defined("options.width",i);let a=t.height??0,n=t.extrudedHeight??a;this._positions=r,this._ellipsoid=g.clone(t.ellipsoid??g.default),this._vertexFormat=o.clone(t.vertexFormat??o.DEFAULT),this._width=i,this._height=Math.max(a,n),this._extrudedHeight=Math.min(a,n),this._cornerType=t.cornerType??e.ROUNDED,this._granularity=t.granularity??b.RADIANS_PER_DEGREE,this._shadowVolume=t.shadowVolume??!1,this._workerName="createCorridorGeometry",this._offsetAttribute=t.offsetAttribute,this._rectangle=void 0,this.packedLength=1+r.length*f.packedLength+g.packedLength+o.packedLength+7}G.pack=function(t,e,r){y.defined("value",t),y.defined("array",e),r=r??0;let i=t._positions,a=i.length;e[r++]=a;for(let t=0;t<a;++t,r+=f.packedLength)f.pack(i[t],e,r);return g.pack(t._ellipsoid,e,r),r+=g.packedLength,o.pack(t._vertexFormat,e,r),r+=o.packedLength,e[r++]=t._width,e[r++]=t._height,e[r++]=t._extrudedHeight,e[r++]=t._cornerType,e[r++]=t._granularity,e[r++]=t._shadowVolume?1:0,e[r]=t._offsetAttribute??-1,e};var C=g.clone(g.UNIT_SPHERE),B=new o,z={positions:void 0,ellipsoid:C,vertexFormat:B,width:void 0,height:void 0,extrudedHeight:void 0,cornerType:void 0,granularity:void 0,shadowVolume:void 0,offsetAttribute:void 0};G.unpack=function(t,e,r){y.defined("array",t),e=e??0;let i=t[e++],a=Array(i);for(let r=0;r<i;++r,e+=f.packedLength)a[r]=f.unpack(t,e);let n=g.unpack(t,e,C);e+=g.packedLength;let l=o.unpack(t,e,B);e+=o.packedLength;let s=t[e++],u=t[e++],d=t[e++],m=t[e++],h=t[e++],c=1===t[e++],p=t[e];return _(r)?(r._positions=a,r._ellipsoid=g.clone(n,r._ellipsoid),r._vertexFormat=o.clone(l,r._vertexFormat),r._width=s,r._height=u,r._extrudedHeight=d,r._cornerType=m,r._granularity=h,r._shadowVolume=c,r._offsetAttribute=-1===p?void 0:p,r):(z.positions=a,z.width=s,z.height=u,z.extrudedHeight=d,z.cornerType=m,z.granularity=h,z.shadowVolume=c,z.offsetAttribute=-1===p?void 0:p,new G(z))},G.computeRectangle=function(t,r){let o=(t=t??A.EMPTY_OBJECT).positions,i=t.width;return y.defined("options.positions",o),y.defined("options.width",i),Y(o,t.ellipsoid??g.default,i,t.cornerType??e.ROUNDED,r)},G.createGeometry=function(e){let l=e._positions,h=e._width,p=e._ellipsoid,g=a(l=I(l,p),f.equalsEpsilon);if(g.length<2||h<=0)return;let A=e._height,y=e._extrudedHeight,P=!b.equalsEpsilon(A,y,0,b.EPSILON2),F=e._vertexFormat,O={ellipsoid:p,positions:g,width:h,cornerType:e._cornerType,granularity:e._granularity,saveAttributes:!0},L;if(P)O.height=A,O.extrudedHeight=y,O.shadowVolume=e._shadowVolume,O.offsetAttribute=e._offsetAttribute,L=function(e,a){let l,s,u,m,h=new o({position:a.position,normal:a.normal||a.bitangent||e.shadowVolume,tangent:a.tangent,bitangent:a.normal||a.bitangent,st:a.st}),p=e.ellipsoid,g=M(t.computePositions(e),h,p),A=e.height,b=e.extrudedHeight,y=g.attributes,P=g.indices,F=y.position.values,I=F.length,O=new Float64Array(6*I),L=new Float64Array(I);L.set(F);let S=new Float64Array(4*I);S=x(F=i.scaleToGeodeticHeight(F,A,p),0,S),S=x(L=i.scaleToGeodeticHeight(L,b,p),2*I,S),O.set(F),O.set(L,I),O.set(S,2*I),y.position.values=O,y=function(e,r){if(!r.normal&&!r.tangent&&!r.bitangent&&!r.st)return e;let o=e.position.values,i,a;(r.normal||r.bitangent)&&(i=e.normal.values,a=e.bitangent.values);let n=e.position.values.length/18,l=3*n,s=2*n,u=2*l,d;if(r.normal||r.bitangent||r.tangent){let n=r.normal?new Float32Array(6*l):void 0,s=r.tangent?new Float32Array(6*l):void 0,m=r.bitangent?new Float32Array(6*l):void 0,h=w,c=v,p=T,g=E,A=k,b=N,y=u;for(d=0;d<l;d+=3){let e=y+u;h=f.fromArray(o,d,h),c=f.fromArray(o,d+l,c),p=f.fromArray(o,(d+3)%l,p),c=f.subtract(c,h,c),p=f.subtract(p,h,p),g=f.normalize(f.cross(c,p,g),g),r.normal&&(t.addAttribute(n,g,e),t.addAttribute(n,g,e+3),t.addAttribute(n,g,y),t.addAttribute(n,g,y+3)),(r.tangent||r.bitangent)&&(b=f.fromArray(i,d,b),r.bitangent&&(t.addAttribute(m,b,e),t.addAttribute(m,b,e+3),t.addAttribute(m,b,y),t.addAttribute(m,b,y+3)),r.tangent&&(A=f.normalize(f.cross(b,g,A),A),t.addAttribute(s,A,e),t.addAttribute(s,A,e+3),t.addAttribute(s,A,y),t.addAttribute(s,A,y+3))),y+=6}if(r.normal){for(n.set(i),d=0;d<l;d+=3)n[d+l]=-i[d],n[d+l+1]=-i[d+1],n[d+l+2]=-i[d+2];e.normal.values=n}else e.normal=void 0;if(r.bitangent?(m.set(a),m.set(a,l),e.bitangent.values=m):e.bitangent=void 0,r.tangent){let t=e.tangent.values;s.set(t),s.set(t,l),e.tangent.values=s}}if(r.st){let t=e.st.values,r=new Float32Array(6*s);r.set(t),r.set(t,s);let o=2*s;for(let e=0;e<2;e++){for(r[o++]=t[0],r[o++]=t[1],d=2;d<s;d+=2){let e=t[d],i=t[d+1];r[o++]=e,r[o++]=i,r[o++]=e,r[o++]=i}r[o++]=t[0],r[o++]=t[1]}e.st.values=r}return e}(y,a);let V,j=I/3;if(e.shadowVolume){let t=y.normal.values,e=new Float32Array(6*(I=t.length));for(V=0;V<I;V++)t[V]=-t[V];e.set(t,I),e=x(t,4*I,e),y.extrudeDirection=new d({componentDatatype:c.FLOAT,componentsPerAttribute:3,values:e}),a.normal||(y.normal=void 0)}if(_(e.offsetAttribute)){let t=new Uint8Array(6*j);if(e.offsetAttribute===r.TOP)t=t.fill(1,0,j).fill(1,2*j,4*j);else{let o=e.offsetAttribute===r.NONE?0:1;t=t.fill(o)}y.applyOffset=new d({componentDatatype:c.UNSIGNED_BYTE,componentsPerAttribute:1,values:t})}let D=P.length,R=j+j,H=n.createTypedArray(O.length/3,2*D+3*R);H.set(P);let U=D;for(V=0;V<D;V+=3){let t=P[V],e=P[V+1],r=P[V+2];H[U++]=r+j,H[U++]=e+j,H[U++]=t+j}for(V=0;V<R;V+=2)s=(l=V+R)+R,u=l+1,m=s+1,H[U++]=l,H[U++]=s,H[U++]=u,H[U++]=u,H[U++]=s,H[U++]=m;return{attributes:y,indices:H}}(O,F);else if((L=M(t.computePositions(O),F,p)).attributes.position.values=i.scaleToGeodeticHeight(L.attributes.position.values,A,p),_(e._offsetAttribute)){let t=e._offsetAttribute===r.NONE?0:1,o=new Uint8Array(L.attributes.position.values.length/3).fill(t);L.attributes.applyOffset=new d({componentDatatype:c.UNSIGNED_BYTE,componentsPerAttribute:1,values:o})}let S=L.attributes,V=m.fromVertices(S.position.values,void 0,3);return F.position||(L.attributes.position.values=void 0),new u({attributes:S,indices:L.indices,primitiveType:s.TRIANGLES,boundingSphere:V,offsetAttribute:e._offsetAttribute})},G.createShadowVolume=function(t,e,r){let i=t._granularity,a=t._ellipsoid,n=e(i,a),l=r(i,a);return new G({positions:t._positions,width:t._width,cornerType:t._cornerType,ellipsoid:a,granularity:i,extrudedHeight:n,height:l,vertexFormat:o.POSITION_ONLY,shadowVolume:!0})},Object.defineProperties(G.prototype,{rectangle:{get:function(){return _(this._rectangle)||(this._rectangle=Y(this._positions,this._ellipsoid,this._width,this._cornerType)),this._rectangle}},textureCoordinateRotationPoints:{get:function(){return[0,0,0,1,1,0]}}});var J=function(t,e){return _(e)&&(t=G.unpack(t,e)),t._ellipsoid=g.clone(t._ellipsoid),G.createGeometry(t)};export{J as default};