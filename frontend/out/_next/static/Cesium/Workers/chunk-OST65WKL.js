import{b as t,f as e,g as n,h as r,i as i}from"./chunk-4PT23TTH.js";import{a as o,b as s,c as a,e as u,f as I}from"./chunk-I4JBCTLR.js";import{a as N}from"./chunk-5IUKPU5Q.js";import{a as m,b as p}from"./chunk-BOXFFUY5.js";import{e as T}from"./chunk-OVZZEY7C.js";var c=Object.freeze({NONE:0,TRIANGLES:1,LINES:2,POLYLINES:3}),b={POINTS:N.POINTS,LINES:N.LINES,LINE_LOOP:N.LINE_LOOP,LINE_STRIP:N.LINE_STRIP,TRIANGLES:N.TRIANGLES,TRIANGLE_STRIP:N.TRIANGLE_STRIP,TRIANGLE_FAN:N.TRIANGLE_FAN};b.isLines=function(t){return t===b.LINES||t===b.LINE_LOOP||t===b.LINE_STRIP},b.isTriangles=function(t){return t===b.TRIANGLES||t===b.TRIANGLE_STRIP||t===b.TRIANGLE_FAN},b.validate=function(t){return t===b.POINTS||t===b.LINES||t===b.LINE_LOOP||t===b.LINE_STRIP||t===b.TRIANGLES||t===b.TRIANGLE_STRIP||t===b.TRIANGLE_FAN};var E=Object.freeze(b);function l(t){t=t??I.EMPTY_OBJECT,p.typeOf.object("options.attributes",t.attributes),this.attributes=t.attributes,this.indices=t.indices,this.primitiveType=t.primitiveType??E.TRIANGLES,this.boundingSphere=t.boundingSphere,this.geometryType=t.geometryType??c.NONE,this.boundingSphereCV=t.boundingSphereCV,this.offsetAttribute=t.offsetAttribute}l.computeNumberOfVertices=function(t){p.typeOf.object("geometry",t);let e=-1;for(let n in t.attributes)if(t.attributes.hasOwnProperty(n)&&T(t.attributes[n])&&T(t.attributes[n].values)){let r=t.attributes[n],i=r.values.length/r.componentsPerAttribute;if(e!==i&&-1!==e)throw new m("All attribute lists must have the same number of attributes.");e=i}return e};var h=new s,f=new o,A=new t,L=[new s,new s,new s],y=[new a,new a,new a],P=[new a,new a,new a],w=new o,S=new e,O=new t,R=new i;l._textureCoordinateRotationPoints=function(I,N,m,p){let T,c=r.center(p,h),b=s.toCartesian(c,m,f),E=n.eastNorthUpToFixedFrame(b,m,A),l=t.inverse(E,A);L[0].longitude=p.west,L[0].latitude=p.south,L[1].longitude=p.west,L[1].latitude=p.north,L[2].longitude=p.east,L[2].latitude=p.south;let _=w;for(T=0;T<3;T++)s.toCartesian(L[T],m,_),_=t.multiplyByPointAsVector(l,_,_),y[T].x=_.x,y[T].y=_.y;let d=e.fromAxisAngle(o.UNIT_Z,-N,S),x=u.fromQuaternion(d,O),G=I.length,g=Number.POSITIVE_INFINITY,v=Number.POSITIVE_INFINITY,F=Number.NEGATIVE_INFINITY,V=Number.NEGATIVE_INFINITY;for(T=0;T<G;T++)_=t.multiplyByPointAsVector(l,I[T],_),g=Math.min(g,(_=u.multiplyByVector(x,_,_)).x),v=Math.min(v,_.y),F=Math.max(F,_.x),V=Math.max(V,_.y);let j=i.fromRotation(N,R);P[0].x=g,P[0].y=v,P[1].x=g,P[1].y=V,P[2].x=F,P[2].y=v;let C=y[0],Y=y[2].x-C.x,k=y[1].y-C.y;for(T=0;T<3;T++){let t=P[T];i.multiplyByVector(j,t,t),t.x=(t.x-C.x)/Y,t.y=(t.y-C.y)/k}let B=P[0],M=P[1],U=P[2],z=Array(6);return a.pack(B,z),a.pack(M,z,2),a.pack(U,z,4),z};var _=l,d=function(t){if(!T((t=t??I.EMPTY_OBJECT).componentDatatype))throw new m("options.componentDatatype is required.");if(!T(t.componentsPerAttribute))throw new m("options.componentsPerAttribute is required.");if(t.componentsPerAttribute<1||t.componentsPerAttribute>4)throw new m("options.componentsPerAttribute must be between 1 and 4.");if(!T(t.values))throw new m("options.values is required.");this.componentDatatype=t.componentDatatype,this.componentsPerAttribute=t.componentsPerAttribute,this.normalize=t.normalize??!1,this.values=t.values};export{c as a,E as b,_ as c,d as d};