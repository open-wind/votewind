import{a as t}from"./chunk-GSY3BJ4Q.js";import{a as e}from"./chunk-NHZSQ3M4.js";import{a as o}from"./chunk-4KTYBIT7.js";import{a as i}from"./chunk-PYEWQREH.js";import{a as n}from"./chunk-7Q53UG4E.js";import"./chunk-OFGHX2F3.js";import"./chunk-GT4KWHVH.js";import{a as r}from"./chunk-HNJRTQHB.js";import{a as a}from"./chunk-PJSC3CZC.js";import{a as s}from"./chunk-VRX6MZUH.js";import"./chunk-EMIRY7IE.js";import{a as l,b as u}from"./chunk-AKNTYFRF.js";import"./chunk-VKBMYYL4.js";import"./chunk-MQ2J7IEP.js";import{a as c,b as h}from"./chunk-LHHREGTA.js";import"./chunk-O2LOQWK4.js";import{a as p}from"./chunk-I4PVU2XE.js";import"./chunk-TMRGWDA2.js";import{c as g,d as m}from"./chunk-OST65WKL.js";import{d as d}from"./chunk-KLPRJ6SC.js";import{f as f,h as y}from"./chunk-4PT23TTH.js";import{a as _}from"./chunk-J4RA3VLE.js";import{a as P,b as T,c as w,d as I,e as O,f as b}from"./chunk-I4JBCTLR.js";import{a as E}from"./chunk-MCEXFPZL.js";import"./chunk-5IUKPU5Q.js";import"./chunk-B3NSNNUV.js";import{a as A,b as H}from"./chunk-BOXFFUY5.js";import{e as x}from"./chunk-OVZZEY7C.js";function v(t,e){this.position=t,x(this.position)||(this.position=new w),this.tangentPlane=e,x(this.tangentPlane)||(this.tangentPlane=v.NORTH_POLE_TANGENT_PLANE)}Object.defineProperties(v.prototype,{ellipsoid:{get:function(){return this.tangentPlane.ellipsoid}},x:{get:function(){return this.position.x}},y:{get:function(){return this.position.y}},conformalLatitude:{get:function(){let t=w.magnitude(this.position),e=2*this.ellipsoid.maximumRadius;return this.tangentPlane.plane.normal.z*(E.PI_OVER_TWO-2*Math.atan2(t,e))}},longitude:{get:function(){let t=E.PI_OVER_TWO+Math.atan2(this.y,this.x);return t>Math.PI&&(t-=E.TWO_PI),t}}});var N=new T,R=new P;v.prototype.getLatitude=function(t){x(t)||(t=I.default),N.latitude=this.conformalLatitude,N.longitude=this.longitude,N.height=0;let e=this.ellipsoid.cartographicToCartesian(N,R);return t.cartesianToCartographic(e,N),N.latitude};var L=new c,k=new P,C=new P;v.fromCartesian=function(t,e){H.defined("cartesian",t);let o=E.signNotZero(t.z),i=v.NORTH_POLE_TANGENT_PLANE,n=v.SOUTH_POLE;o<0&&(i=v.SOUTH_POLE_TANGENT_PLANE,n=v.NORTH_POLE),L.origin=i.ellipsoid.scaleToGeocentricSurface(t,L.origin),L.direction=P.subtract(L.origin,n,k),P.normalize(L.direction,L.direction);let r=h.rayPlane(L,i.plane,C),a=P.subtract(r,n,r),s=P.dot(i.xAxis,a),l=o*P.dot(i.yAxis,a);return x(e)?(e.position=new w(s,l),e.tangentPlane=i,e):new v(new w(s,l),i)},v.fromCartesianArray=function(t,e){H.defined("cartesians",t);let o=t.length;x(e)?e.length=o:e=Array(o);for(let i=0;i<o;i++)e[i]=v.fromCartesian(t[i],e[i]);return e},v.clone=function(t,e){if(x(t))return x(e)?(e.position=t.position,e.tangentPlane=t.tangentPlane,e):new v(t.position,t.tangentPlane)},v.HALF_UNIT_SPHERE=Object.freeze(new I(.5,.5,.5)),v.NORTH_POLE=Object.freeze(new P(0,0,.5)),v.SOUTH_POLE=Object.freeze(new P(0,0,-.5)),v.NORTH_POLE_TANGENT_PLANE=Object.freeze(new s(v.NORTH_POLE,v.HALF_UNIT_SPHERE)),v.SOUTH_POLE_TANGENT_PLANE=Object.freeze(new s(v.SOUTH_POLE,v.HALF_UNIT_SPHERE));var F=new T,j=new T,S=new t,V=new P,G=new P,B=new P,M=new P,U=new P,z=new P,W=new P,D=new P,Y=new P,K=new w,Q=new w,Z=new P,J=new f,X=new O,q=new O;function $(t){let e=t.vertexFormat,o=t.geometry,i=t.shadowVolume,n=o.attributes.position.values,a=x(o.attributes.st)?o.attributes.st.values:void 0,s=n.length,l=t.wall,u=t.top||l,c=t.bottom||l;if(e.st||e.normal||e.tangent||e.bitangent||i){let r=t.boundingRectangle,h=t.rotationAxis,p=t.projectTo2d,g=t.ellipsoid,d=t.stRotation,y=t.perPositionHeight;K.x=r.x,K.y=r.y;let T=e.st?new Float32Array(s/3*2):void 0,I;e.normal&&(I=y&&u&&!l?o.attributes.normal.values:new Float32Array(s));let b=e.tangent?new Float32Array(s):void 0,A=e.bitangent?new Float32Array(s):void 0,H=i?new Float32Array(s):void 0,v=0,N=0,R=G,L=B,k=M,C=!0,S=X,$=q;if(0!==d){let t=f.fromAxisAngle(h,d,J);S=O.fromQuaternion(t,S),t=f.fromAxisAngle(h,-d,J),$=O.fromQuaternion(t,$)}else S=O.clone(O.IDENTITY,S),$=O.clone(O.IDENTITY,$);let tt=0,te=0;u&&c&&(tt=s/2,te=s/3,s/=2);for(let o=0;o<s;o+=3){let h=P.fromArray(n,o,Z);if(e.st&&!x(a)){let t=O.multiplyByVector(S,h,V),e=p([t=g.scaleToGeodeticSurface(t,t)],Q)[0];w.subtract(e,K,e);let o=E.clamp(e.x/r.width,0,1),i=E.clamp(e.y/r.height,0,1);c&&(T[v+te]=o,T[v+1+te]=i),u&&(T[v]=o,T[v+1]=i),v+=2}if(e.normal||e.tangent||e.bitangent||i){let r=N+1,a=N+2;if(l){if(o+3<s){let t=P.fromArray(n,o+3,U);if(C){let e=P.fromArray(n,o+s,z);y&&function(t,e,o,i){let n=i.cartesianToCartographic(t,F).height,r=i.cartesianToCartographic(e,j);r.height=n,i.cartographicToCartesian(r,e);let a=i.cartesianToCartographic(o,j);a.height=n-100,i.cartographicToCartesian(a,o)}(h,t,e,g),P.subtract(t,h,t),P.subtract(e,h,e),R=P.normalize(P.cross(e,t,R),R),C=!1}P.equalsEpsilon(t,h,E.EPSILON10)&&(C=!0)}(e.tangent||e.bitangent)&&(k=g.geodeticSurfaceNormal(h,k),e.tangent&&(L=P.normalize(P.cross(k,R,L),L)))}else R=g.geodeticSurfaceNormal(h,R),(e.tangent||e.bitangent)&&(y&&(W=P.fromArray(I,N,W),D=P.cross(P.UNIT_Z,W,D),D=P.normalize(O.multiplyByVector($,D,D),D),e.bitangent&&(Y=P.normalize(P.cross(W,D,Y),Y))),L=P.cross(P.UNIT_Z,R,L),L=P.normalize(O.multiplyByVector($,L,L),L),e.bitangent&&(k=P.normalize(P.cross(R,L,k),k)));e.normal&&(t.wall?(I[N+tt]=R.x,I[r+tt]=R.y,I[a+tt]=R.z):c&&(I[N+tt]=-R.x,I[r+tt]=-R.y,I[a+tt]=-R.z),(u&&!y||l)&&(I[N]=R.x,I[r]=R.y,I[a]=R.z)),i&&(l&&(R=g.geodeticSurfaceNormal(h,R)),H[N+tt]=-R.x,H[r+tt]=-R.y,H[a+tt]=-R.z),e.tangent&&(t.wall?(b[N+tt]=L.x,b[r+tt]=L.y,b[a+tt]=L.z):c&&(b[N+tt]=-L.x,b[r+tt]=-L.y,b[a+tt]=-L.z),u&&(y?(b[N]=D.x,b[r]=D.y,b[a]=D.z):(b[N]=L.x,b[r]=L.y,b[a]=L.z))),e.bitangent&&(c&&(A[N+tt]=k.x,A[r+tt]=k.y,A[a+tt]=k.z),u&&(y?(A[N]=Y.x,A[r]=Y.y,A[a]=Y.z):(A[N]=k.x,A[r]=k.y,A[a]=k.z))),N+=3}}e.st&&!x(a)&&(o.attributes.st=new m({componentDatatype:_.FLOAT,componentsPerAttribute:2,values:T})),e.normal&&(o.attributes.normal=new m({componentDatatype:_.FLOAT,componentsPerAttribute:3,values:I})),e.tangent&&(o.attributes.tangent=new m({componentDatatype:_.FLOAT,componentsPerAttribute:3,values:b})),e.bitangent&&(o.attributes.bitangent=new m({componentDatatype:_.FLOAT,componentsPerAttribute:3,values:A})),i&&(o.attributes.extrudeDirection=new m({componentDatatype:_.FLOAT,componentsPerAttribute:3,values:H}))}if(t.extrude&&x(t.offsetAttribute)){let e=n.length/3,i=new Uint8Array(e);if(t.offsetAttribute===r.TOP)u&&c||l?i=i.fill(1,0,e/2):u&&(i=i.fill(1));else{let e=t.offsetAttribute===r.NONE?0:1;i=i.fill(e)}o.attributes.applyOffset=new m({componentDatatype:_.UNSIGNED_BYTE,componentsPerAttribute:1,values:i})}return o}var tt=[];function te(t){if(H.typeOf.object("options",t),H.typeOf.object("options.polygonHierarchy",t.polygonHierarchy),x(t.perPositionHeight)&&t.perPositionHeight&&x(t.height))throw new A("Cannot use both options.perPositionHeight and options.height");if(x(t.arcType)&&t.arcType!==o.GEODESIC&&t.arcType!==o.RHUMB)throw new A("Invalid arcType. Valid options are ArcType.GEODESIC and ArcType.RHUMB.");let i=t.polygonHierarchy,n=t.vertexFormat??a.DEFAULT,r=t.ellipsoid??I.default,s=t.granularity??E.RADIANS_PER_DEGREE,l=t.stRotation??0,u=t.textureCoordinates,c=t.perPositionHeight??!1,h=c&&x(t.extrudedHeight),p=t.height??0,g=t.extrudedHeight??p;if(!h){let t=Math.max(p,g);g=Math.min(p,g),p=t}this._vertexFormat=a.clone(n),this._ellipsoid=I.clone(r),this._granularity=s,this._stRotation=l,this._height=p,this._extrudedHeight=g,this._closeTop=t.closeTop??!0,this._closeBottom=t.closeBottom??!0,this._polygonHierarchy=i,this._perPositionHeight=c,this._perPositionHeightExtrude=h,this._shadowVolume=t.shadowVolume??!1,this._workerName="createPolygonGeometry",this._offsetAttribute=t.offsetAttribute,this._arcType=t.arcType??o.GEODESIC,this._rectangle=void 0,this._textureCoordinateRotationPoints=void 0,this._textureCoordinates=u,this.packedLength=e.computeHierarchyPackedLength(i,P)+I.packedLength+a.packedLength+(u?e.computeHierarchyPackedLength(u,w):1)+12}te.fromPositions=function(t){return t=t??b.EMPTY_OBJECT,H.defined("options.positions",t.positions),new te({polygonHierarchy:{positions:t.positions},height:t.height,extrudedHeight:t.extrudedHeight,vertexFormat:t.vertexFormat,stRotation:t.stRotation,ellipsoid:t.ellipsoid,granularity:t.granularity,perPositionHeight:t.perPositionHeight,closeTop:t.closeTop,closeBottom:t.closeBottom,offsetAttribute:t.offsetAttribute,arcType:t.arcType,textureCoordinates:t.textureCoordinates})},te.pack=function(t,o,i){return H.typeOf.object("value",t),H.defined("array",o),i=i??0,i=e.packPolygonHierarchy(t._polygonHierarchy,o,i,P),I.pack(t._ellipsoid,o,i),i+=I.packedLength,a.pack(t._vertexFormat,o,i),i+=a.packedLength,o[i++]=t._height,o[i++]=t._extrudedHeight,o[i++]=t._granularity,o[i++]=t._stRotation,o[i++]=t._perPositionHeightExtrude?1:0,o[i++]=t._perPositionHeight?1:0,o[i++]=t._closeTop?1:0,o[i++]=t._closeBottom?1:0,o[i++]=t._shadowVolume?1:0,o[i++]=t._offsetAttribute??-1,o[i++]=t._arcType,x(t._textureCoordinates)?i=e.packPolygonHierarchy(t._textureCoordinates,o,i,w):o[i++]=-1,o[i++]=t.packedLength,o};var to=I.clone(I.UNIT_SPHERE),ti=new a,tn={polygonHierarchy:{}};te.unpack=function(t,o,i){H.defined("array",t),o=o??0;let n=e.unpackPolygonHierarchy(t,o,P);o=n.startingIndex,delete n.startingIndex;let r=I.unpack(t,o,to);o+=I.packedLength;let s=a.unpack(t,o,ti);o+=a.packedLength;let l=t[o++],u=t[o++],c=t[o++],h=t[o++],p=1===t[o++],g=1===t[o++],m=1===t[o++],d=1===t[o++],f=1===t[o++],y=t[o++],_=t[o++],T=-1===t[o]?void 0:e.unpackPolygonHierarchy(t,o,w);x(T)?(o=T.startingIndex,delete T.startingIndex):o++;let O=t[o++];return x(i)||(i=new te(tn)),i._polygonHierarchy=n,i._ellipsoid=I.clone(r,i._ellipsoid),i._vertexFormat=a.clone(s,i._vertexFormat),i._height=l,i._extrudedHeight=u,i._granularity=c,i._stRotation=h,i._perPositionHeightExtrude=p,i._perPositionHeight=g,i._closeTop=m,i._closeBottom=d,i._shadowVolume=f,i._offsetAttribute=-1===y?void 0:y,i._arcType=_,i._textureCoordinates=T,i.packedLength=O,i};var tr=new w,ta=new w,ts=new v;function tl(t,e,i,n,r,a){let s=t.longitude,l=s>=0?s:s+E.TWO_PI;r.westOverIdl=Math.min(r.westOverIdl,l),r.eastOverIdl=Math.max(r.eastOverIdl,l),a.west=Math.min(a.west,s),a.east=Math.max(a.east,s);let u=t.getLatitude(i),c=u;if(a.south=Math.min(a.south,u),a.north=Math.max(a.north,u),n!==o.RHUMB){let o=w.subtract(e.position,t.position,tr),n=w.dot(e.position,o)/w.dot(o,o);if(n>0&&n<1){let t=w.add(e.position,w.multiplyByScalar(o,-n,o),ta),r=v.clone(e,ts);r.position=t;let s=r.getLatitude(i);a.south=Math.min(a.south,s),a.north=Math.max(a.north,s),Math.abs(u)>Math.abs(s)&&(c=s)}}let h=Math.sign(e.x*t.y-t.x*e.y);0!==h&&(h*=w.angleBetween(e.position,t.position)),c>=0&&(r.northAngle+=h),c<=0&&(r.southAngle+=h)}var tu=new v,tc=new v,th={northAngle:0,southAngle:0,westOverIdl:0,eastOverIdl:0};te.computeRectangleFromPositions=function(t,e,o,i){if(H.defined("positions",t),x(i)||(i=new y),t.length<3)return i;i.west=Number.POSITIVE_INFINITY,i.east=Number.NEGATIVE_INFINITY,i.south=Number.POSITIVE_INFINITY,i.north=Number.NEGATIVE_INFINITY,th.northAngle=0,th.southAngle=0,th.westOverIdl=Number.POSITIVE_INFINITY,th.eastOverIdl=Number.NEGATIVE_INFINITY;let n=t.length,r=v.fromCartesian(t[0],tc);for(let a=1;a<n;a++){let n=v.fromCartesian(t[a],tu);tl(n,r,e,o,th,i),r=v.clone(n,r)}return tl(v.fromCartesian(t[0],tu),r,e,o,th,i),i.east-i.west>th.eastOverIdl-th.westOverIdl&&(i.west=th.westOverIdl,i.east=th.eastOverIdl,i.east>E.PI&&(i.east=i.east-E.TWO_PI),i.west>E.PI&&(i.west=i.west-E.TWO_PI)),E.equalsEpsilon(Math.abs(th.northAngle),E.TWO_PI,E.EPSILON10)&&(i.north=E.PI_OVER_TWO,i.east=E.PI,i.west=-E.PI),E.equalsEpsilon(Math.abs(th.southAngle),E.TWO_PI,E.EPSILON10)&&(i.south=-E.PI_OVER_TWO,i.east=E.PI,i.west=-E.PI),i};var tp=new v,tg=new T;te.createGeometry=function(o){let a=o._vertexFormat,c=o._ellipsoid,h=o._granularity,f=o._stRotation,y=o._polygonHierarchy,P=o._perPositionHeight,T=o._closeTop,I=o._closeBottom,O=o._arcType,b=o._textureCoordinates,A=x(b),H=y.positions;if(H.length<3)return;let N=o.rectangle,R=e.polygonsFromHierarchy(y,A,(t,e)=>{if(N.height>=E.PI||N.width>=E.PI){if(N.south<0&&N.north>0){x(e)||(e=[]);for(let o=0;o<t.length;++o){let i=c.cartesianToCartographic(t[o],tg);e[o]=new w(i.longitude/E.PI,i.latitude/E.PI_OVER_TWO)}return e.length=t.length,e}return v.fromCartesianArray(t,e)}return s.fromPoints(H,c).projectPointsOntoPlane(t,e)},!P,c,(t,o)=>!P&&(N.height>=E.PI_OVER_TWO||N.width>=2*E.PI_OVER_THREE)?e.splitPolygonsOnEquator(t,c,O,o):t),L=R.hierarchy,k=R.polygons,C=A?e.polygonsFromHierarchy(b,!0,function(t){return t},!1,c).polygons:void 0;if(0===L.length)return;let F=L[0].outerRing,j=function(o,i,n,r){if(i.height>=E.PI||i.width>=E.PI)return t.fromRectangle(i,void 0,S);let a=s.fromPoints(o,n);return e.computeBoundingRectangle(a.plane.normal,a.projectPointOntoPlane.bind(a),o,r,S)}(F,N,c,f),V=[],G=o._height,B=o._extrudedHeight,M=o._perPositionHeightExtrude||!E.equalsEpsilon(G,B,0,E.EPSILON2),U={perPositionHeight:P,vertexFormat:a,geometry:void 0,rotationAxis:(N.height>=E.PI||N.width>=E.PI?v.fromCartesian(F[0],tp).tangentPlane:s.fromPoints(F,c)).plane.normal,projectTo2d:function(t,e,o){if(t.height>=E.PI||t.width>=E.PI)return(e,i)=>{if(t.south<0&&t.north>0){let t=o.cartesianToCartographic(e,tg);return x(i)||(i=new w),i.x=t.longitude/E.PI,i.y=t.latitude/E.PI_OVER_TWO,i}return v.fromCartesian(e,i)};let i=s.fromPoints(e,o);return(t,e)=>i.projectPointsOntoPlane(t,e)}(N,F,c),boundingRectangle:j,ellipsoid:c,stRotation:f,textureCoordinates:void 0,bottom:!1,top:!0,wall:!1,extrude:!1,arcType:O},z;if(M)for(U.extrude=!0,U.top=T,U.bottom=I,U.shadowVolume=o._shadowVolume,U.offsetAttribute=o._offsetAttribute,z=0;z<k.length;z++){let t=function(t,o,n,r,a,c,h,g,m,d){let f={walls:[]},y;if(h||g){let a=e.createGeometryFromPositions(t,o,n,r,c,m,d),s=a.attributes.position.values,l=a.indices,u,_;if(h&&g){let t=s.concat(s);u=t.length/3,(_=p.createTypedArray(u,2*l.length)).set(l);let e=l.length,o=u/2;for(y=0;y<e;y+=3){let t=_[y]+o,i=_[y+1]+o,n=_[y+2]+o;_[y+e]=n,_[y+1+e]=i,_[y+2+e]=t}if(a.attributes.position.values=t,c&&m.normal){let e=a.attributes.normal.values;a.attributes.normal.values=new Float32Array(t.length),a.attributes.normal.values.set(e)}if(m.st&&x(n)){let t=a.attributes.st.values;a.attributes.st.values=new Float32Array(2*u),a.attributes.st.values=t.concat(t)}a.indices=_}else if(g){for(u=s.length/3,_=p.createTypedArray(u,l.length),y=0;y<l.length;y+=3)_[y]=l[y+2],_[y+1]=l[y+1],_[y+2]=l[y];a.indices=_}f.topAndBottom=new i({geometry:a})}let _=a.outerRing,P=s.fromPoints(_,t),T=P.projectPointsOntoPlane(_,tt),w=u.computeWindingOrder2D(T);w===l.CLOCKWISE&&(_=_.slice().reverse());let I=e.computeWallGeometry(_,n,t,r,c,d);f.walls.push(new i({geometry:I}));let O=a.holes;for(y=0;y<O.length;y++){let o=O[y];T=P.projectPointsOntoPlane(o,tt),(w=u.computeWindingOrder2D(T))===l.COUNTER_CLOCKWISE&&(o=o.slice().reverse()),I=e.computeWallGeometry(o,n,t,r,c,d),f.walls.push(new i({geometry:I}))}return f}(c,k[z],A?C[z]:void 0,h,L[z],P,T,I,a,O),o;T&&I?(o=t.topAndBottom,U.geometry=e.scaleToGeodeticHeightExtruded(o.geometry,G,B,c,P)):T?((o=t.topAndBottom).geometry.attributes.position.values=u.scaleToGeodeticHeight(o.geometry.attributes.position.values,G,c,!P),U.geometry=o.geometry):I&&((o=t.topAndBottom).geometry.attributes.position.values=u.scaleToGeodeticHeight(o.geometry.attributes.position.values,B,c,!0),U.geometry=o.geometry),(T||I)&&(U.wall=!1,o.geometry=$(U),V.push(o));let n=t.walls;U.wall=!0;for(let t=0;t<n.length;t++){let o=n[t];U.geometry=e.scaleToGeodeticHeightExtruded(o.geometry,G,B,c,P),o.geometry=$(U),V.push(o)}}else for(z=0;z<k.length;z++){let t=new i({geometry:e.createGeometryFromPositions(c,k[z],A?C[z]:void 0,h,P,a,O)});if(t.geometry.attributes.position.values=u.scaleToGeodeticHeight(t.geometry.attributes.position.values,G,c,!P),U.geometry=t.geometry,t.geometry=$(U),x(o._offsetAttribute)){let e=t.geometry.attributes.position.values.length,i=o._offsetAttribute===r.NONE?0:1,n=new Uint8Array(e/3).fill(i);t.geometry.attributes.applyOffset=new m({componentDatatype:_.UNSIGNED_BYTE,componentsPerAttribute:1,values:n})}V.push(t)}let W=n.combineInstances(V)[0];W.attributes.position.values=new Float64Array(W.attributes.position.values),W.indices=p.createTypedArray(W.attributes.position.values.length/3,W.indices);let D=W.attributes,Y=d.fromVertices(D.position.values);return a.position||delete D.position,new g({attributes:D,indices:W.indices,primitiveType:W.primitiveType,boundingSphere:Y,offsetAttribute:o._offsetAttribute})},te.createShadowVolume=function(t,e,o){let i=t._granularity,n=t._ellipsoid,r=e(i,n),s=o(i,n);return new te({polygonHierarchy:t._polygonHierarchy,ellipsoid:n,stRotation:t._stRotation,granularity:i,perPositionHeight:!1,extrudedHeight:r,height:s,vertexFormat:a.POSITION_ONLY,shadowVolume:!0,arcType:t._arcType})},Object.defineProperties(te.prototype,{rectangle:{get:function(){if(!x(this._rectangle)){let t=this._polygonHierarchy.positions;this._rectangle=te.computeRectangleFromPositions(t,this._ellipsoid,this._arcType)}return this._rectangle}},textureCoordinateRotationPoints:{get:function(){return x(this._textureCoordinateRotationPoints)||(this._textureCoordinateRotationPoints=function(t){let e=-t._stRotation;if(0===e)return[0,0,0,1,1,0];let o=t._ellipsoid,i=t._polygonHierarchy.positions,n=t.rectangle;return g._textureCoordinateRotationPoints(i,e,o,n)}(this)),this._textureCoordinateRotationPoints}}});var tm=function(t,e){return x(e)&&(t=te.unpack(t,e)),t._ellipsoid=I.clone(t._ellipsoid),te.createGeometry(t)};export{tm as default};