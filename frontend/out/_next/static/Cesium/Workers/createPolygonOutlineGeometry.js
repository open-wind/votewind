import{a as e}from"./chunk-NHZSQ3M4.js";import{a as t}from"./chunk-4KTYBIT7.js";import{a as i}from"./chunk-PYEWQREH.js";import{a as r}from"./chunk-7Q53UG4E.js";import"./chunk-OFGHX2F3.js";import"./chunk-GT4KWHVH.js";import{a as o}from"./chunk-HNJRTQHB.js";import{a as n}from"./chunk-VRX6MZUH.js";import"./chunk-EMIRY7IE.js";import{a as s,b as a}from"./chunk-AKNTYFRF.js";import"./chunk-VKBMYYL4.js";import"./chunk-MQ2J7IEP.js";import"./chunk-LHHREGTA.js";import"./chunk-O2LOQWK4.js";import{a as p}from"./chunk-I4PVU2XE.js";import{a as u}from"./chunk-TMRGWDA2.js";import{b as l,c as h,d as c}from"./chunk-OST65WKL.js";import{d as f}from"./chunk-KLPRJ6SC.js";import"./chunk-4PT23TTH.js";import{a as d}from"./chunk-J4RA3VLE.js";import{a as y,d as g,f as m}from"./chunk-I4JBCTLR.js";import{a as H}from"./chunk-MCEXFPZL.js";import"./chunk-5IUKPU5Q.js";import"./chunk-B3NSNNUV.js";import{a as E,b as _}from"./chunk-BOXFFUY5.js";import{e as b}from"./chunk-OVZZEY7C.js";var k=[],P=[];function T(i){if(_.typeOf.object("options",i),_.typeOf.object("options.polygonHierarchy",i.polygonHierarchy),i.perPositionHeight&&b(i.height))throw new E("Cannot use both options.perPositionHeight and options.height");if(b(i.arcType)&&i.arcType!==t.GEODESIC&&i.arcType!==t.RHUMB)throw new E("Invalid arcType. Valid options are ArcType.GEODESIC and ArcType.RHUMB.");let r=i.polygonHierarchy,o=i.ellipsoid??g.default,n=i.granularity??H.RADIANS_PER_DEGREE,s=i.perPositionHeight??!1,a=s&&b(i.extrudedHeight),p=i.arcType??t.GEODESIC,u=i.height??0,l=i.extrudedHeight??u;if(!a){let e=Math.max(u,l);l=Math.min(u,l),u=e}this._ellipsoid=g.clone(o),this._granularity=n,this._height=u,this._extrudedHeight=l,this._arcType=p,this._polygonHierarchy=r,this._perPositionHeight=s,this._perPositionHeightExtrude=a,this._offsetAttribute=i.offsetAttribute,this._workerName="createPolygonOutlineGeometry",this.packedLength=e.computeHierarchyPackedLength(r,y)+g.packedLength+8}T.pack=function(t,i,r){return _.typeOf.object("value",t),_.defined("array",i),r=r??0,r=e.packPolygonHierarchy(t._polygonHierarchy,i,r,y),g.pack(t._ellipsoid,i,r),r+=g.packedLength,i[r++]=t._height,i[r++]=t._extrudedHeight,i[r++]=t._granularity,i[r++]=t._perPositionHeightExtrude?1:0,i[r++]=t._perPositionHeight?1:0,i[r++]=t._arcType,i[r++]=t._offsetAttribute??-1,i[r]=t.packedLength,i};var A=g.clone(g.UNIT_SPHERE),O={polygonHierarchy:{}};T.unpack=function(t,i,r){_.defined("array",t),i=i??0;let o=e.unpackPolygonHierarchy(t,i,y);i=o.startingIndex,delete o.startingIndex;let n=g.unpack(t,i,A);i+=g.packedLength;let s=t[i++],a=t[i++],p=t[i++],u=1===t[i++],l=1===t[i++],h=t[i++],c=t[i++],f=t[i];return b(r)||(r=new T(O)),r._polygonHierarchy=o,r._ellipsoid=g.clone(n,r._ellipsoid),r._height=s,r._extrudedHeight=a,r._granularity=p,r._perPositionHeight=l,r._perPositionHeightExtrude=u,r._arcType=h,r._offsetAttribute=-1===c?void 0:c,r.packedLength=f,r},T.fromPositions=function(e){return e=e??m.EMPTY_OBJECT,_.defined("options.positions",e.positions),new T({polygonHierarchy:{positions:e.positions},height:e.height,extrudedHeight:e.extrudedHeight,ellipsoid:e.ellipsoid,granularity:e.granularity,perPositionHeight:e.perPositionHeight,arcType:e.arcType,offsetAttribute:e.offsetAttribute})},T.createGeometry=function(y){let g=y._ellipsoid,m=y._granularity,E=y._polygonHierarchy,_=y._perPositionHeight,T=y._arcType,A=e.polygonOutlinesFromHierarchy(E,!_,g);if(0===A.length)return;let O,j=[],v=H.chordLength(m,g.maximumRadius),L=y._height,I=y._extrudedHeight,R,w;if(y._perPositionHeightExtrude||!H.equalsEpsilon(L,I,0,H.EPSILON2))for(w=0;w<A.length;w++){if((O=function(r,o,f,y,g){let m=n.fromPoints(o,r).projectPointsOntoPlane(o,k);a.computeWindingOrder2D(m)===s.CLOCKWISE&&(m.reverse(),o=o.slice().reverse());let H,E,_=o.length,b=Array(_),T=0;if(y)for(H=new Float64Array(12*_),E=0;E<_;++E){b[E]=T/3;let e=o[E],t=o[(E+1)%_];H[T++]=e.x,H[T++]=e.y,H[T++]=e.z,H[T++]=t.x,H[T++]=t.y,H[T++]=t.z}else{let i=0;if(g===t.GEODESIC)for(E=0;E<_;E++)i+=e.subdivideLineCount(o[E],o[(E+1)%_],f);else if(g===t.RHUMB)for(E=0;E<_;E++)i+=e.subdivideRhumbLineCount(r,o[E],o[(E+1)%_],f);for(H=new Float64Array(6*i),E=0;E<_;++E){let i;b[E]=T/3,g===t.GEODESIC?i=e.subdivideLine(o[E],o[(E+1)%_],f,P):g===t.RHUMB&&(i=e.subdivideRhumbLine(r,o[E],o[(E+1)%_],f,P));let n=i.length;for(let e=0;e<n;++e)H[T++]=i[e]}}_=H.length/6;let A=b.length,O=(2*_+A)*2,j=p.createTypedArray(_+A,O);for(T=0,E=0;E<_;++E)j[T++]=E,j[T++]=(E+1)%_,j[T++]=E+_,j[T++]=(E+1)%_+_;for(E=0;E<A;E++){let e=b[E];j[T++]=e,j[T++]=e+_}return new i({geometry:new h({attributes:new u({position:new c({componentDatatype:d.DOUBLE,componentsPerAttribute:3,values:H})}),indices:j,primitiveType:l.LINES})})}(g,A[w],v,_,T)).geometry=e.scaleToGeodeticHeightExtruded(O.geometry,L,I,g,_),b(y._offsetAttribute)){let e=O.geometry.attributes.position.values.length/3,t=new Uint8Array(e);y._offsetAttribute===o.TOP?t=t.fill(1,0,e/2):(R=y._offsetAttribute===o.NONE?0:1,t=t.fill(R)),O.geometry.attributes.applyOffset=new c({componentDatatype:d.UNSIGNED_BYTE,componentsPerAttribute:1,values:t})}j.push(O)}else for(w=0;w<A.length;w++){if((O=function(r,o,f,y,g){let m=n.fromPoints(o,r).projectPointsOntoPlane(o,k);a.computeWindingOrder2D(m)===s.CLOCKWISE&&(m.reverse(),o=o.slice().reverse());let H,E,_=o.length,b=0;if(y)for(H=new Float64Array(6*_),E=0;E<_;E++){let e=o[E],t=o[(E+1)%_];H[b++]=e.x,H[b++]=e.y,H[b++]=e.z,H[b++]=t.x,H[b++]=t.y,H[b++]=t.z}else{let i=0;if(g===t.GEODESIC)for(E=0;E<_;E++)i+=e.subdivideLineCount(o[E],o[(E+1)%_],f);else if(g===t.RHUMB)for(E=0;E<_;E++)i+=e.subdivideRhumbLineCount(r,o[E],o[(E+1)%_],f);for(H=new Float64Array(3*i),E=0;E<_;E++){let i;g===t.GEODESIC?i=e.subdivideLine(o[E],o[(E+1)%_],f,P):g===t.RHUMB&&(i=e.subdivideRhumbLine(r,o[E],o[(E+1)%_],f,P));let n=i.length;for(let e=0;e<n;++e)H[b++]=i[e]}}let T=2*(_=H.length/3),A=p.createTypedArray(_,T);for(b=0,E=0;E<_-1;E++)A[b++]=E,A[b++]=E+1;return A[b++]=_-1,A[b++]=0,new i({geometry:new h({attributes:new u({position:new c({componentDatatype:d.DOUBLE,componentsPerAttribute:3,values:H})}),indices:A,primitiveType:l.LINES})})}(g,A[w],v,_,T)).geometry.attributes.position.values=a.scaleToGeodeticHeight(O.geometry.attributes.position.values,L,g,!_),b(y._offsetAttribute)){let e=O.geometry.attributes.position.values.length;R=y._offsetAttribute===o.NONE?0:1;let t=new Uint8Array(e/3).fill(R);O.geometry.attributes.applyOffset=new c({componentDatatype:d.UNSIGNED_BYTE,componentsPerAttribute:1,values:t})}j.push(O)}let x=r.combineInstances(j)[0],C=f.fromVertices(x.attributes.position.values);return new h({attributes:x.attributes,indices:x.indices,primitiveType:x.primitiveType,boundingSphere:C,offsetAttribute:y._offsetAttribute})};var j=function(e,t){return b(t)&&(e=T.unpack(e,t)),e._ellipsoid=g.clone(e._ellipsoid),T.createGeometry(e)};export{j as default};