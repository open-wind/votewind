import{a as e}from"./chunk-GSY3BJ4Q.js";import{a as o,c as r}from"./chunk-YUGVMPE3.js";import"./chunk-XTBKSAXL.js";import"./chunk-F27AWPUY.js";import"./chunk-VRX6MZUH.js";import"./chunk-EMIRY7IE.js";import{a as i,b as t}from"./chunk-AKNTYFRF.js";import{a as n}from"./chunk-VKBMYYL4.js";import"./chunk-MQ2J7IEP.js";import"./chunk-LHHREGTA.js";import"./chunk-O2LOQWK4.js";import{a as s}from"./chunk-I4PVU2XE.js";import{a as a}from"./chunk-TMRGWDA2.js";import{b as p,c as c,d as l}from"./chunk-OST65WKL.js";import{d as h}from"./chunk-KLPRJ6SC.js";import"./chunk-4PT23TTH.js";import{a as u}from"./chunk-J4RA3VLE.js";import{a as m,c as k,d as d,f as f}from"./chunk-I4JBCTLR.js";import{a as y}from"./chunk-MCEXFPZL.js";import"./chunk-5IUKPU5Q.js";import"./chunk-B3NSNNUV.js";import{a as g}from"./chunk-BOXFFUY5.js";import{e as _}from"./chunk-OVZZEY7C.js";function j(e){let r=(e=e??f.EMPTY_OBJECT).polylinePositions,i=e.shapePositions;if(!_(r))throw new g("options.polylinePositions is required.");if(!_(i))throw new g("options.shapePositions is required.");this._positions=r,this._shape=i,this._ellipsoid=d.clone(e.ellipsoid??d.default),this._cornerType=e.cornerType??o.ROUNDED,this._granularity=e.granularity??y.RADIANS_PER_DEGREE,this._workerName="createPolylineVolumeOutlineGeometry";let t=1+r.length*m.packedLength;t+=1+i.length*k.packedLength,this.packedLength=t+d.packedLength+2}j.pack=function(e,o,r){if(!_(e))throw new g("value is required");if(!_(o))throw new g("array is required");r=r??0;let i,t=e._positions,n=t.length;for(o[r++]=n,i=0;i<n;++i,r+=m.packedLength)m.pack(t[i],o,r);let s=e._shape;for(n=s.length,o[r++]=n,i=0;i<n;++i,r+=k.packedLength)k.pack(s[i],o,r);return d.pack(e._ellipsoid,o,r),r+=d.packedLength,o[r++]=e._cornerType,o[r]=e._granularity,o};var P=d.clone(d.UNIT_SPHERE),E={polylinePositions:void 0,shapePositions:void 0,ellipsoid:P,height:void 0,cornerType:void 0,granularity:void 0};j.unpack=function(e,o,r){if(!_(e))throw new g("array is required");o=o??0;let i,t=e[o++],n=Array(t);for(i=0;i<t;++i,o+=m.packedLength)n[i]=m.unpack(e,o);let s=Array(t=e[o++]);for(i=0;i<t;++i,o+=k.packedLength)s[i]=k.unpack(e,o);let a=d.unpack(e,o,P);o+=d.packedLength;let p=e[o++],c=e[o];return _(r)?(r._positions=n,r._shape=s,r._ellipsoid=d.clone(a,r._ellipsoid),r._cornerType=p,r._granularity=c,r):(E.polylinePositions=n,E.shapePositions=s,E.cornerType=p,E.granularity=c,new j(E))};var L=new e;j.createGeometry=function(o){let k=n(o._positions,m.equalsEpsilon),d=o._shape;if(d=r.removeDuplicatesFromShape(d),k.length<2||d.length<3)return;t.computeWindingOrder2D(d)===i.CLOCKWISE&&d.reverse();let f=e.fromPoints(d,L);return function(e,o){let r=new a;r.position=new l({componentDatatype:u.DOUBLE,componentsPerAttribute:3,values:e});let i=o.length,t=r.position.values.length/3,n=e.length/3/i,m=s.createTypedArray(t,2*i*(n+1)),k,d,f=0,y=(k=0)*i;for(d=0;d<i-1;d++)m[f++]=d+y,m[f++]=d+y+1;for(m[f++]=i-1+y,m[f++]=y,y=(k=n-1)*i,d=0;d<i-1;d++)m[f++]=d+y,m[f++]=d+y+1;for(m[f++]=i-1+y,m[f++]=y,k=0;k<n-1;k++){let e=i*k,o=e+i;for(d=0;d<i;d++)m[f++]=d+e,m[f++]=d+o}return new c({attributes:r,indices:s.createTypedArray(t,m),boundingSphere:h.fromVertices(e),primitiveType:p.LINES})}(r.computePositions(k,d,f,o,!1),d)};var T=function(e,o){return _(o)&&(e=j.unpack(e,o)),e._ellipsoid=d.clone(e._ellipsoid),j.createGeometry(e)};export{T as default};