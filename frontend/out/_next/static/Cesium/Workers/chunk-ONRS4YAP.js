import{a as t}from"./chunk-GVXEIANZ.js";import{a as e}from"./chunk-HNJRTQHB.js";import{a as o}from"./chunk-PJSC3CZC.js";import{a as n}from"./chunk-I4PVU2XE.js";import{a as r}from"./chunk-TMRGWDA2.js";import{b as a,c as i,d as s}from"./chunk-OST65WKL.js";import{d as u}from"./chunk-KLPRJ6SC.js";import{a as m}from"./chunk-J4RA3VLE.js";import{a as f,c as p,f as l}from"./chunk-I4JBCTLR.js";import{a as c}from"./chunk-MCEXFPZL.js";import{a as d}from"./chunk-BOXFFUY5.js";import{e as h}from"./chunk-OVZZEY7C.js";var b,w=new p,A=new f,g=new f,y=new f,_=new f;function v(t){let n=(t=t??l.EMPTY_OBJECT).length,r=t.topRadius,a=t.bottomRadius,i=t.vertexFormat??o.DEFAULT,s=t.slices??128;if(!h(n))throw new d("options.length must be defined.");if(!h(r))throw new d("options.topRadius must be defined.");if(!h(a))throw new d("options.bottomRadius must be defined.");if(s<3)throw new d("options.slices must be greater than or equal to 3.");if(h(t.offsetAttribute)&&t.offsetAttribute===e.TOP)throw new d("GeometryOffsetAttribute.TOP is not a supported options.offsetAttribute for this geometry.");this._length=n,this._topRadius=r,this._bottomRadius=a,this._vertexFormat=o.clone(i),this._slices=s,this._offsetAttribute=t.offsetAttribute,this._workerName="createCylinderGeometry"}v.packedLength=o.packedLength+5,v.pack=function(t,e,n){if(!h(t))throw new d("value is required");if(!h(e))throw new d("array is required");return n=n??0,o.pack(t._vertexFormat,e,n),n+=o.packedLength,e[n++]=t._length,e[n++]=t._topRadius,e[n++]=t._bottomRadius,e[n++]=t._slices,e[n]=t._offsetAttribute??-1,e};var R=new o,k={vertexFormat:R,length:void 0,topRadius:void 0,bottomRadius:void 0,slices:void 0,offsetAttribute:void 0};v.unpack=function(t,e,n){if(!h(t))throw new d("array is required");e=e??0;let r=o.unpack(t,e,R);e+=o.packedLength;let a=t[e++],i=t[e++],s=t[e++],u=t[e++],m=t[e];return h(n)?(n._vertexFormat=o.clone(r,n._vertexFormat),n._length=a,n._topRadius=i,n._bottomRadius=s,n._slices=u,n._offsetAttribute=-1===m?void 0:m,n):(k.length=a,k.topRadius=i,k.bottomRadius=s,k.slices=u,k.offsetAttribute=-1===m?void 0:m,new v(k))},v.createGeometry=function(o){let l=o._length,d=o._topRadius,b=o._bottomRadius,v=o._vertexFormat,R=o._slices;if(l<=0||d<0||b<0||0===d&&0===b)return;let k=R+R,x=R+k,F=k+k,T=t.computePositions(l,d,b,R,!0),O=v.st?new Float32Array(2*F):void 0,L=v.normal?new Float32Array(3*F):void 0,P=v.tangent?new Float32Array(3*F):void 0,E=v.bitangent?new Float32Array(3*F):void 0,j,N=v.normal||v.tangent||v.bitangent;if(N){let t=v.tangent||v.bitangent,e=0,o=0,n=0,r=Math.atan2(b-d,l);A.z=Math.sin(r);let a=Math.cos(r),i=y,s=g;for(j=0;j<R;j++){let r=j/R*c.TWO_PI,u=a*Math.cos(r),m=a*Math.sin(r);N&&(A.x=u,A.y=m,t&&(i=f.normalize(f.cross(f.UNIT_Z,A,i),i)),v.normal&&(L[e++]=A.x,L[e++]=A.y,L[e++]=A.z,L[e++]=A.x,L[e++]=A.y,L[e++]=A.z),v.tangent&&(P[o++]=i.x,P[o++]=i.y,P[o++]=i.z,P[o++]=i.x,P[o++]=i.y,P[o++]=i.z),v.bitangent&&(s=f.normalize(f.cross(A,i,s),s),E[n++]=s.x,E[n++]=s.y,E[n++]=s.z,E[n++]=s.x,E[n++]=s.y,E[n++]=s.z))}for(j=0;j<R;j++)v.normal&&(L[e++]=0,L[e++]=0,L[e++]=-1),v.tangent&&(P[o++]=1,P[o++]=0,P[o++]=0),v.bitangent&&(E[n++]=0,E[n++]=-1,E[n++]=0);for(j=0;j<R;j++)v.normal&&(L[e++]=0,L[e++]=0,L[e++]=1),v.tangent&&(P[o++]=1,P[o++]=0,P[o++]=0),v.bitangent&&(E[n++]=0,E[n++]=1,E[n++]=0)}let C=n.createTypedArray(F,12*R-12),D=0,M=0;for(j=0;j<R-1;j++)C[D++]=M,C[D++]=M+2,C[D++]=M+3,C[D++]=M,C[D++]=M+3,C[D++]=M+1,M+=2;for(C[D++]=k-2,C[D++]=0,C[D++]=1,C[D++]=k-2,C[D++]=1,C[D++]=k-1,j=1;j<R-1;j++)C[D++]=k+j+1,C[D++]=k+j,C[D++]=k;for(j=1;j<R-1;j++)C[D++]=x,C[D++]=x+j,C[D++]=x+j+1;let z=0;if(v.st){let t=Math.max(d,b);for(j=0;j<F;j++){let e=f.fromArray(T,3*j,_);O[z++]=(e.x+t)/(2*t),O[z++]=(e.y+t)/(2*t)}}let I=new r;v.position&&(I.position=new s({componentDatatype:m.DOUBLE,componentsPerAttribute:3,values:T})),v.normal&&(I.normal=new s({componentDatatype:m.FLOAT,componentsPerAttribute:3,values:L})),v.tangent&&(I.tangent=new s({componentDatatype:m.FLOAT,componentsPerAttribute:3,values:P})),v.bitangent&&(I.bitangent=new s({componentDatatype:m.FLOAT,componentsPerAttribute:3,values:E})),v.st&&(I.st=new s({componentDatatype:m.FLOAT,componentsPerAttribute:2,values:O})),w.x=.5*l,w.y=Math.max(b,d);let G=new u(f.ZERO,p.magnitude(w));if(h(o._offsetAttribute)){l=T.length;let t=o._offsetAttribute===e.NONE?0:1,n=new Uint8Array(l/3).fill(t);I.applyOffset=new s({componentDatatype:m.UNSIGNED_BYTE,componentsPerAttribute:1,values:n})}return new i({attributes:I,indices:C,primitiveType:a.TRIANGLES,boundingSphere:G,offsetAttribute:o._offsetAttribute})},v.getUnitCylinder=function(){return h(b)||(b=v.createGeometry(new v({topRadius:1,bottomRadius:1,length:1,vertexFormat:o.POSITION_ONLY}))),b};var x=v;export{x as a};