import{a as t,b as e}from"./chunk-FVPDHHYC.js";import{a as r}from"./chunk-3WQQGQIW.js";import{a as i}from"./chunk-R6YCVUGT.js";import"./chunk-OFGHX2F3.js";import{a as n}from"./chunk-EMIRY7IE.js";import{a as o}from"./chunk-I4PVU2XE.js";import"./chunk-KLPRJ6SC.js";import{b as a,g as s,h as h}from"./chunk-4PT23TTH.js";import"./chunk-J4RA3VLE.js";import{a as u,b as c,c as l,d as I}from"./chunk-I4JBCTLR.js";import{a as d}from"./chunk-MCEXFPZL.js";import"./chunk-5IUKPU5Q.js";import"./chunk-B3NSNNUV.js";import{a as m}from"./chunk-BOXFFUY5.js";import{e as g}from"./chunk-OVZZEY7C.js";function T(){m.throwInstantiationError()}Object.defineProperties(T.prototype,{errorEvent:{get:m.throwInstantiationError},credit:{get:m.throwInstantiationError},tilingScheme:{get:m.throwInstantiationError},hasWaterMask:{get:m.throwInstantiationError},hasVertexNormals:{get:m.throwInstantiationError},availability:{get:m.throwInstantiationError}});var f=[];T.getRegularGridIndices=function(t,e){if(t*e>=d.FOUR_GIGABYTES)throw new m("The total number of vertices (width * height) must be less than 4,294,967,296.");let r=f[t];g(r)||(f[t]=r=[]);let i=r[e];return g(i)||(i=t*e<d.SIXTY_FOUR_KILOBYTES?r[e]=new Uint16Array((t-1)*(e-1)*6):r[e]=new Uint32Array((t-1)*(e-1)*6),y(t,e,i,0)),i};var N=[];T.getRegularGridIndicesAndEdgeIndices=function(t,e){if(t*e>=d.FOUR_GIGABYTES)throw new m("The total number of vertices (width * height) must be less than 4,294,967,296.");let r=N[t];g(r)||(N[t]=r=[]);let i=r[e];if(!g(i)){let n=T.getRegularGridIndices(t,e),o=E(t,e),a=o.westIndicesSouthToNorth,s=o.southIndicesEastToWest,h=o.eastIndicesNorthToSouth,u=o.northIndicesWestToEast;i=r[e]={indices:n,westIndicesSouthToNorth:a,southIndicesEastToWest:s,eastIndicesNorthToSouth:h,northIndicesWestToEast:u}}return i};var p=[];function E(t,e){let r=Array(e),i=Array(t),n=Array(e),o=Array(t),a;for(a=0;a<t;++a)o[a]=a,i[a]=t*e-1-a;for(a=0;a<e;++a)n[a]=(a+1)*t-1,r[a]=(e-a-1)*t;return{westIndicesSouthToNorth:r,southIndicesEastToWest:i,eastIndicesNorthToSouth:n,northIndicesWestToEast:o}}function y(t,e,r,i){let n=0;for(let o=0;o<e-1;++o){for(let e=0;e<t-1;++e){let e=n,o=e+t,a=o+1,s=e+1;r[i++]=e,r[i++]=o,r[i++]=s,r[i++]=s,r[i++]=o,r[i++]=a,++n}++n}}function w(t,e,r,i){let n=t[0],o=t.length;for(let a=1;a<o;++a){let o=t[a];r[i++]=n,r[i++]=o,r[i++]=e,r[i++]=e,r[i++]=o,r[i++]=e+1,n=o,++e}return i}T.getRegularGridAndSkirtIndicesAndEdgeIndices=function(t,e){if(t*e>=d.FOUR_GIGABYTES)throw new m("The total number of vertices (width * height) must be less than 4,294,967,296.");let r=p[t];g(r)||(p[t]=r=[]);let i=r[e];if(!g(i)){let n=t*e,a=(t-1)*(e-1)*6,s=2*t+2*e,h=6*Math.max(0,s-4),u=E(t,e),c=u.westIndicesSouthToNorth,l=u.southIndicesEastToWest,I=u.eastIndicesNorthToSouth,d=u.northIndicesWestToEast,m=o.createTypedArray(n+s,a+h);y(t,e,m,0),T.addSkirtIndices(c,l,I,d,n,m,a),i=r[e]={indices:m,westIndicesSouthToNorth:c,southIndicesEastToWest:l,eastIndicesNorthToSouth:I,northIndicesWestToEast:d,indexCountWithoutSkirts:a}}return i},T.addSkirtIndices=function(t,e,r,i,n,o,a){let s=n;a=w(t,s,o,a),s+=t.length,a=w(e,s,o,a),s+=e.length,a=w(r,s,o,a),w(i,s+=r.length,o,a)},T.heightmapTerrainQuality=.25,T.getEstimatedLevelZeroGeometricErrorForAHeightmap=function(t,e,r){return 2*t.maximumRadius*Math.PI*T.heightmapTerrainQuality/(e*r)},T.prototype.requestTileGeometry=m.throwInstantiationError,T.prototype.getLevelMaximumGeometricError=m.throwInstantiationError,T.prototype.getTileDataAvailable=m.throwInstantiationError,T.prototype.loadTileDataAvailability=m.throwInstantiationError;var S=new u,b=new u,A=new u,k=new c,x=new l;function F(t,e,r,i,n,o,s,h,c){let l=Number.POSITIVE_INFINITY,I=n.north,m=n.south,g=n.east,T=n.west;g<T&&(g+=d.TWO_PI);let f=t.length;for(let n=0;n<f;++n){let f=t[n],N=r[f],p=i[f];k.longitude=d.lerp(T,g,p.x),k.latitude=d.lerp(m,I,p.y),k.height=N-e;let E=o.cartographicToCartesian(k,S);a.multiplyByPoint(s,E,E),u.minimumByComponent(E,h,h),u.maximumByComponent(E,c,c),l=Math.min(l,k.height)}return l}function G(t,e,r,n,o,a,s,h,u,c,l,I,m,T){let f=g(s),N=u.north,p=u.south,E=u.east,y=u.west;E<y&&(E+=d.TWO_PI);let w=r.length;for(let u=0;u<w;++u){let g,w,b=r[u],A=o[b],F=a[b];k.longitude=d.lerp(y,E,F.x)+m,k.latitude=d.lerp(p,N,F.y)+T,k.height=A-c;let G=h.cartographicToCartesian(k,S);if(f){let t=2*b;x.x=s[t],x.y=s[t+1]}n.hasWebMercatorT&&(g=(i.geodeticLatitudeToMercatorAngle(k.latitude)-l)*I),n.hasGeodeticSurfaceNormals&&(w=h.geodeticSurfaceNormal(G)),e=n.encode(t,e,G,F,k.height,x,g,w)}}function M(t,e){let r;return"function"==typeof t.slice&&"function"!=typeof(r=t.slice()).sort&&(r=void 0),g(r)||(r=Array.prototype.slice.call(t)),r.sort(e),r}var P=r(function(r,c){let m=r.quantizedVertices,f=m.length/3,N=r.octEncodedNormals,p=r.westIndices.length+r.eastIndices.length+r.southIndices.length+r.northIndices.length,E=r.includeWebMercatorT,y=r.exaggeration,w=r.exaggerationRelativeHeight,P=1!==y,W=h.clone(r.rectangle),Y=W.west,v=W.south,H=W.east,V=W.north,_=I.clone(r.ellipsoid),C=r.minimumHeight,O=r.maximumHeight,j=r.relativeToCenter,R=s.eastNorthUpToFixedFrame(j,_),U=a.inverseTransformation(R,new a),B,L;E&&(B=i.geodeticLatitudeToMercatorAngle(v),L=1/(i.geodeticLatitudeToMercatorAngle(V)-B));let Q=m.subarray(0,f),X=m.subarray(f,2*f),z=m.subarray(2*f,3*f),Z=g(N),D=Array(f),J=Array(f),K=Array(f),q=E?Array(f):[],$=P?Array(f):[];b.x=Number.POSITIVE_INFINITY,b.y=Number.POSITIVE_INFINITY,b.z=Number.POSITIVE_INFINITY,A.x=Number.NEGATIVE_INFINITY,A.y=Number.NEGATIVE_INFINITY,A.z=Number.NEGATIVE_INFINITY;let tt=Number.POSITIVE_INFINITY,te=Number.NEGATIVE_INFINITY,tr=Number.POSITIVE_INFINITY,ti=Number.NEGATIVE_INFINITY;for(let t=0;t<f;++t){let e=Q[t],r=X[t],n=e/32767,o=r/32767,s=d.lerp(C,O,z[t]/32767);k.longitude=d.lerp(Y,H,n),k.latitude=d.lerp(v,V,o),k.height=s,tt=Math.min(k.longitude,tt),te=Math.max(k.longitude,te),tr=Math.min(k.latitude,tr),ti=Math.max(k.latitude,ti);let h=_.cartographicToCartesian(k);D[t]=new l(n,o),J[t]=s,K[t]=h,E&&(q[t]=(i.geodeticLatitudeToMercatorAngle(k.latitude)-B)*L),P&&($[t]=_.geodeticSurfaceNormal(h)),a.multiplyByPoint(U,h,S),u.minimumByComponent(S,b,b),u.maximumByComponent(S,A,A)}let tn=M(r.westIndices,function(t,e){return D[t].y-D[e].y}),to=M(r.eastIndices,function(t,e){return D[e].y-D[t].y}),ta=M(r.southIndices,function(t,e){return D[e].x-D[t].x}),ts=M(r.northIndices,function(t,e){return D[t].x-D[e].x}),th;C<0&&(th=new t(_).computeHorizonCullingPointPossiblyUnderEllipsoid(j,K,C));let tu=C;tu=Math.min(tu=Math.min(tu=Math.min(tu=Math.min(tu,F(r.westIndices,r.westSkirtHeight,J,D,W,_,U,b,A)),F(r.southIndices,r.southSkirtHeight,J,D,W,_,U,b,A)),F(r.eastIndices,r.eastSkirtHeight,J,D,W,_,U,b,A)),F(r.northIndices,r.northSkirtHeight,J,D,W,_,U,b,A));let tc=new n(b,A,j),tl=new e(j,tc,tu,O,R,Z,E,P,y,w),tI=tl.stride,td=new Float32Array(f*tI+p*tI),tm=0;for(let t=0;t<f;++t){if(Z){let e=2*t;x.x=N[e],x.y=N[e+1]}tm=tl.encode(td,tm,K[t],D[t],J[t],x,q[t],$[t])}let tg=Math.max(0,(p-4)*2),tT=r.indices.length+3*tg,tf=o.createTypedArray(f+p,tT);tf.set(r.indices,0);let tN=(te-tt)*1e-4,tp=(ti-tr)*1e-4,tE=f*tI;return G(td,tE,tn,tl,J,D,N,_,W,r.westSkirtHeight,B,L,-tN,0),G(td,tE+=r.westIndices.length*tI,ta,tl,J,D,N,_,W,r.southSkirtHeight,B,L,0,-tp),G(td,tE+=r.southIndices.length*tI,to,tl,J,D,N,_,W,r.eastSkirtHeight,B,L,tN,0),G(td,tE+=r.eastIndices.length*tI,ts,tl,J,D,N,_,W,r.northSkirtHeight,B,L,0,tp),T.addSkirtIndices(tn,ta,to,ts,f,tf,r.indices.length),c.push(td.buffer,tf.buffer),{vertices:td.buffer,indices:tf.buffer,westIndicesSouthToNorth:tn,southIndicesEastToWest:ta,eastIndicesNorthToSouth:to,northIndicesWestToEast:ts,vertexStride:tI,center:j,minimumHeight:C,maximumHeight:O,occludeePointInScaledSpace:th,encoding:tl,indexCountWithoutSkirts:r.indices.length}});export{P as default};