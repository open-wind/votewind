import{a as i}from"./chunk-HNJRTQHB.js";import{a as t}from"./chunk-I4PVU2XE.js";import{a as o}from"./chunk-TMRGWDA2.js";import{b as e,c as r,d as n}from"./chunk-OST65WKL.js";import{d as a}from"./chunk-KLPRJ6SC.js";import{a as s}from"./chunk-J4RA3VLE.js";import{a as m,d as u,f as f}from"./chunk-I4JBCTLR.js";import{a as c}from"./chunk-MCEXFPZL.js";import{a as l}from"./chunk-BOXFFUY5.js";import{e as d}from"./chunk-OVZZEY7C.js";var h=new m(1,1,1),_=Math.cos,k=Math.sin;function p(t){let o=(t=t??f.EMPTY_OBJECT).radii??h,e=t.innerRadii??o,r=t.minimumClock??0,n=t.maximumClock??c.TWO_PI,a=t.minimumCone??0,s=t.maximumCone??c.PI,u=Math.round(t.stackPartitions??10),_=Math.round(t.slicePartitions??8),k=Math.round(t.subdivisions??128);if(u<1)throw new l("options.stackPartitions cannot be less than 1");if(_<0)throw new l("options.slicePartitions cannot be less than 0");if(k<0)throw new l("options.subdivisions must be greater than or equal to zero.");if(d(t.offsetAttribute)&&t.offsetAttribute===i.TOP)throw new l("GeometryOffsetAttribute.TOP is not a supported options.offsetAttribute for this geometry.");this._radii=m.clone(o),this._innerRadii=m.clone(e),this._minimumClock=r,this._maximumClock=n,this._minimumCone=a,this._maximumCone=s,this._stackPartitions=u,this._slicePartitions=_,this._subdivisions=k,this._offsetAttribute=t.offsetAttribute,this._workerName="createEllipsoidOutlineGeometry"}p.packedLength=2*m.packedLength+8,p.pack=function(i,t,o){if(!d(i))throw new l("value is required");if(!d(t))throw new l("array is required");return o=o??0,m.pack(i._radii,t,o),o+=m.packedLength,m.pack(i._innerRadii,t,o),o+=m.packedLength,t[o++]=i._minimumClock,t[o++]=i._maximumClock,t[o++]=i._minimumCone,t[o++]=i._maximumCone,t[o++]=i._stackPartitions,t[o++]=i._slicePartitions,t[o++]=i._subdivisions,t[o]=i._offsetAttribute??-1,t};var C=new m,b=new m,P={radii:C,innerRadii:b,minimumClock:void 0,maximumClock:void 0,minimumCone:void 0,maximumCone:void 0,stackPartitions:void 0,slicePartitions:void 0,subdivisions:void 0,offsetAttribute:void 0};p.unpack=function(i,t,o){if(!d(i))throw new l("array is required");t=t??0;let e=m.unpack(i,t,C);t+=m.packedLength;let r=m.unpack(i,t,b);t+=m.packedLength;let n=i[t++],a=i[t++],s=i[t++],u=i[t++],f=i[t++],c=i[t++],h=i[t++],_=i[t];return d(o)?(o._radii=m.clone(e,o._radii),o._innerRadii=m.clone(r,o._innerRadii),o._minimumClock=n,o._maximumClock=a,o._minimumCone=s,o._maximumCone=u,o._stackPartitions=f,o._slicePartitions=c,o._subdivisions=h,o._offsetAttribute=-1===_?void 0:_,o):(P.minimumClock=n,P.maximumClock=a,P.minimumCone=s,P.maximumCone=u,P.stackPartitions=f,P.slicePartitions=c,P.subdivisions=h,P.offsetAttribute=-1===_?void 0:_,new p(P))},p.createGeometry=function(m){let f=m._radii;if(f.x<=0||f.y<=0||f.z<=0)return;let l=m._innerRadii;if(l.x<=0||l.y<=0||l.z<=0)return;let h=m._minimumClock,p=m._maximumClock,C=m._minimumCone,b=m._maximumCone,P=m._subdivisions,y=u.fromCartesian3(f),v=m._slicePartitions+1,w=m._stackPartitions+1;v=Math.round(v*Math.abs(p-h)/c.TWO_PI),w=Math.round(w*Math.abs(b-C)/c.PI),v<2&&(v=2),w<2&&(w=2);let A=0,x=1,g=l.x!==f.x||l.y!==f.y||l.z!==f.z,E=!1,L=!1;g&&(x=2,C>0&&(E=!0,A+=v),b<Math.PI&&(L=!0,A+=v));let M=P*x*(w+v),O=new Float64Array(3*M),T=2*(M+A-(v+w)*x),R=t.createTypedArray(M,T),j,z,I,N,B=0,D=Array(w),G=Array(w);for(j=0;j<w;j++)N=C+j*(b-C)/(w-1),D[j]=k(N),G[j]=_(N);let J=Array(P),S=Array(P);for(j=0;j<P;j++)I=h+j*(p-h)/(P-1),J[j]=k(I),S[j]=_(I);for(j=0;j<w;j++)for(z=0;z<P;z++)O[B++]=f.x*D[j]*S[z],O[B++]=f.y*D[j]*J[z],O[B++]=f.z*G[j];if(g)for(j=0;j<w;j++)for(z=0;z<P;z++)O[B++]=l.x*D[j]*S[z],O[B++]=l.y*D[j]*J[z],O[B++]=l.z*G[j];for(D.length=P,G.length=P,j=0;j<P;j++)N=C+j*(b-C)/(P-1),D[j]=k(N),G[j]=_(N);for(J.length=v,S.length=v,j=0;j<v;j++)I=h+j*(p-h)/(v-1),J[j]=k(I),S[j]=_(I);for(j=0;j<P;j++)for(z=0;z<v;z++)O[B++]=f.x*D[j]*S[z],O[B++]=f.y*D[j]*J[z],O[B++]=f.z*G[j];if(g)for(j=0;j<P;j++)for(z=0;z<v;z++)O[B++]=l.x*D[j]*S[z],O[B++]=l.y*D[j]*J[z],O[B++]=l.z*G[j];for(B=0,j=0;j<w*x;j++){let i=j*P;for(z=0;z<P-1;z++)R[B++]=i+z,R[B++]=i+z+1}let U=w*P*x;for(j=0;j<v;j++)for(z=0;z<P-1;z++)R[B++]=U+j+z*v,R[B++]=U+j+(z+1)*v;if(g)for(U=w*P*x+v*P,j=0;j<v;j++)for(z=0;z<P-1;z++)R[B++]=U+j+z*v,R[B++]=U+j+(z+1)*v;if(g){let i=w*P*x,t=i+P*v;if(E)for(j=0;j<v;j++)R[B++]=i+j,R[B++]=t+j;if(L)for(i+=P*v-v,t+=P*v-v,j=0;j<v;j++)R[B++]=i+j,R[B++]=t+j}let q=new o({position:new n({componentDatatype:s.DOUBLE,componentsPerAttribute:3,values:O})});if(d(m._offsetAttribute)){let t=O.length,o=m._offsetAttribute===i.NONE?0:1,e=new Uint8Array(t/3).fill(o);q.applyOffset=new n({componentDatatype:s.UNSIGNED_BYTE,componentsPerAttribute:1,values:e})}return new r({attributes:q,indices:R,primitiveType:e.LINES,boundingSphere:a.fromEllipsoid(y),offsetAttribute:m._offsetAttribute})};var y=p;export{y as a};